# NMCI - NetworkManager-ci Library

Do not edit this file. This is generated by `sphinx-build` from source [`nmci/doc_src/index.rst`](nmci/doc_src/index.rst).

## Adding standard python module (e.g. `nmci.prepare`)

When created, do not forget to import it at the end of [`nmci/__init__.py`](nmci/_\_init_\_.py) file, otherwise it will not be imported with `import nmci`.

## Adding new module as class (e.g. `nmci.process`)

If module is written as python class `_ClassMod` in `nmci/classmod.py`, do not forget to

1. Define `_module = _ClassMod()` at the end of file.
2. Define `__getattr__()` to avoid not fully loaded modules within `nmci`.

```python
def __getattr__(attr):
    return getattr(_module, attr)
```

1. Add module to file [`nmci/__init__.py`](nmci/_\_init_\_.py):

```python
import nmci.classmod
# this line is important for autocomplete to work correctly
classmod = nmci.classmod._module
sys.modules["nmci.classmod"] = classmod
```

Remember, if you define another classes in `nmci/classmod.py`, they will not be accessible,
unless you set them as attributes of `_ClassMod`.

## Add module to documentation

Add following in [`nmci/doc_src/index.rst`](nmci/doc_src/index.rst):

```markdown
my_new_mod
==========

.. automodule:: nmci.my_new_mod
   :members:
   :undoc-members:
   :show-inheritance:
```

Regenerate the documentation from source:

```bash
sphinx-build -E -a -b markdown nmci/doc_src nmci/doc
```

Results should be in [`nmci/doc/markdown/index.md`](nmci/doc/markdown/index.md).

# API of the nmci modules.

# cext

Context Extenstion object
Remembers the current behave context and implements
basic operations over it.

### nmci.cext.setup(context)

Setup context formatter, commands, and save context.

* **Parameters:**
  **context** (*behave.Context*) – behave context object

### nmci.cext.skip(msg='')

Skip scenario and stop executing (raise SkipTestException).

* **Parameters:**
  **msg** (*str**,* *optional*) – Reason of skip, defaults to “”
* **Raises:**
  [**nmci.misc.SkipTestException**](#nmci.misc.SkipTestException) – Interupts further code execution

# cleanup

### *class* nmci.cleanup.Cleanup(name, unique_tag=None, priority=0)

Bases: `object`

Cleanup base class

* **Parameters:**
  * **name** (*str*) – human readable description, defaults to None
  * **unique_tag** (*object**,* *optional*) – comparison key to merge duplicit cleanups, by default, all instances of Cleanup are considered distinct, all instances of descendant classes are considered equal
  * **priority** (*int**,* *optional*) – defines order in which the cleanups are executed, defaults to PRIORITY_CALLBACK_DEFAULT

#### PRIORITY_CALLBACK_DEFAULT *= 0*

#### PRIORITY_CONNECTION *= 20*

#### PRIORITY_FILE *= 70*

#### PRIORITY_IFACE_DELETE *= 30*

#### PRIORITY_IFACE_RESET *= 31*

#### PRIORITY_MPTCP *= 30*

#### PRIORITY_NAMESPACE *= 30*

#### PRIORITY_NFT_DEFAULT *= 40*

#### PRIORITY_NFT_OTHER *= 41*

#### PRIORITY_NM_SERVICE_RESTART *= 200*

#### PRIORITY_NM_SERVICE_START *= -30*

#### PRIORITY_PEXPECT_SERVICE *= 40*

#### PRIORITY_SYSCTL *= 25*

#### PRIORITY_TAG *= 10*

#### PRIORITY_UDEV_RULE *= 50*

#### PRIORITY_UDEV_UPDATE *= 300*

#### UNIQ_TAG_DISTINCT *= <object object>*

### *class* nmci.cleanup.CleanupCallback(callback, name=None, unique_tag=<object object>, priority=0, also_needs=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

Generic cleanup

* **Parameters:**
  * **callback** (*callable**,* *optional*) – cleanup method to be called, defaults to None
  * **name** (*str**,* *optional*) – human readable description, defaults to None
  * **unique_tag** (*object**,* *optional*) – comparison key to merge duplicit cleanups, by default, all instances of Cleanup are considered distinct, all instances of descendant classes are considered equal
  * **priority** (*int**,* *optional*) – defines order in which the cleanups are executed, defaults to PRIORITY_CALLBACK_DEFAULT
  * **also_needs** (*callable**,* *optional*) – dependent cleanups, should be callable returning iterable of Cleanup objects, defaults to None

### *class* nmci.cleanup.CleanupConnection(con_name, qualifier=None, priority=20)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

Cleanup NetworkManager connection

* **Parameters:**
  * **con_name** (*str**,* *list*) – name or UUID or list of names or UUIDs of the connection to cleanup
  * **qualifier** (*str**,* *optional*) – optional qualifier (‘id’ or ‘uuid’), defaults to None
  * **priority** (*int**,* *optional*) – cleanup priority, defaults to PRIORITY_CONNECTION

### *class* nmci.cleanup.CleanupFile(\*files, glob=None, priority=70, name=None, unique_tag=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

File cleanup, removes file if exists.

* **Parameters:**
  * **priority** (*int**,* *optional*) – cleanup priority, defaults to PRIORITY_FILE
  * **name** (*str**,* *optional*) – description of cleanup, defaults to None
  * **glob** (*string* *or* *iterable* *of* *string**,* *optional*) – glob expression(s) of filenames

#### *classmethod* delete_file(filename)

#### *classmethod* delete_glob(file_glob)

### *class* nmci.cleanup.CleanupIface(iface, op=None, priority=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

Cleanup the network interafce

* **Parameters:**
  * **iface** (*str* *or* *list* *of* *str*) – name of the interface
  * **op** (*str**,* *optional*) – operation, one of ‘delete’, ‘ip-delete’ or ‘reset’, defaults to ‘reset’ on eth0…eth10, ‘delete’ otherwise
  * **priority** (*int**,* *optional*) – cleanup priority, defaults to PRIORITY_IFACE_DELETE or PRIORITY_IFACE_RESET

### *class* nmci.cleanup.CleanupMptcpEndpoints

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

MPTCP endpoint cleanups

### *class* nmci.cleanup.CleanupMptcpLimits(namespace=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

MPTCP limits cleanup

* **Parameters:**
  **namespace** (*str**,* *optional*) – name of namespace, defaults to None

### *class* nmci.cleanup.CleanupNMConfig(config_file, config_directory=None, priority=70, schedule_nm_restart=True)

Bases: [`CleanupFile`](#nmci.cleanup.CleanupFile)

Cleanup NetworkManager config file and restart.

* **Parameters:**
  * **config_file** (*str*) – NetworkManager config file name, either full path, or relative path accepted.
  * **config_directory** (*str**,* *optional*) – NetworkManager config directory, one of ‘etc’, ‘usr’, ‘run’, defaults to ‘etc’
  * **priority** (*int**,* *optional*) – cleanup priority, defaults to PRIORITY_FILE

### *class* nmci.cleanup.CleanupNMService(operation='restart', timeout=None, priority=None, name=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

NetworkManager systemd service cleanup. Accepts start, restart, and reload.

* **Parameters:**
  * **operation** (*str*) – operation on systemd service, one of ‘start’, ‘restart’ or ‘reload’.
  * **priority** (*int**,* *optional*) – cleanup priortiy, defaults to None

### *class* nmci.cleanup.CleanupNamespace(namespace, teardown=True, priority=30)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

Cleanup base class

* **Parameters:**
  * **name** (*str*) – human readable description, defaults to None
  * **unique_tag** (*object**,* *optional*) – comparison key to merge duplicit cleanups, by default, all instances of Cleanup are considered distinct, all instances of descendant classes are considered equal
  * **priority** (*int**,* *optional*) – defines order in which the cleanups are executed, defaults to PRIORITY_CALLBACK_DEFAULT

### *class* nmci.cleanup.CleanupNft(namespace=None, priority=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

NFT rules cleanup

* **Parameters:**
  * **namespace** (*str**,* *optional*) – name of namespace, defaults to None
  * **priority** (*int**,* *optional*) – cleanup priority, defaults to None

### *class* nmci.cleanup.CleanupSysctls(sysctls_pattern, namespace=None)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

Sysctl cleanup - reset to original value.

* **Parameters:**
  * **sysctls_pattern** (*str*) – sysctl pattern to save
  * **namespace** (*str**,* *optional*) – name of namespace, defaults to None

### *class* nmci.cleanup.CleanupUdevRule(rule, priority=50)

Bases: [`CleanupFile`](#nmci.cleanup.CleanupFile)

Udev rule file cleanup

* **Parameters:**
  * **rule** (*str*) – name of file containing udev rule
  * **priority** (*int**,* *optional*) – cleanup priortiy, defaults to PRIORITY_UDEV_RULE

### *class* nmci.cleanup.CleanupUdevUpdate(priority=300)

Bases: [`Cleanup`](#nmci.cleanup.Cleanup)

Udev update cleanup, calls updates and settles udev

* **Parameters:**
  **priority** (*int**,* *optional*) – cleanup priortiy, defaults to PRIORITY_UDEV_UPDATE

### nmci.cleanup.add_NM_config

alias of [`CleanupNMConfig`](#nmci.cleanup.CleanupNMConfig)

### nmci.cleanup.add_NM_service

alias of [`CleanupNMService`](#nmci.cleanup.CleanupNMService)

### nmci.cleanup.add_callback

alias of [`CleanupCallback`](#nmci.cleanup.CleanupCallback)

### nmci.cleanup.add_connection

alias of [`CleanupConnection`](#nmci.cleanup.CleanupConnection)

### nmci.cleanup.add_file

alias of [`CleanupFile`](#nmci.cleanup.CleanupFile)

### nmci.cleanup.add_iface

alias of [`CleanupIface`](#nmci.cleanup.CleanupIface)

### nmci.cleanup.add_mptcp_endpoints

alias of [`CleanupMptcpEndpoints`](#nmci.cleanup.CleanupMptcpEndpoints)

### nmci.cleanup.add_mptcp_limits

alias of [`CleanupMptcpLimits`](#nmci.cleanup.CleanupMptcpLimits)

### nmci.cleanup.add_namespace

alias of [`CleanupNamespace`](#nmci.cleanup.CleanupNamespace)

### nmci.cleanup.add_nft

alias of [`CleanupNft`](#nmci.cleanup.CleanupNft)

### nmci.cleanup.add_sysctls

alias of [`CleanupSysctls`](#nmci.cleanup.CleanupSysctls)

### nmci.cleanup.add_udev_rule

alias of [`CleanupUdevRule`](#nmci.cleanup.CleanupUdevRule)

### nmci.cleanup.process_cleanup()

Exectue the cleanups honoring its order.

* **Returns:**
  list of Exceptions that hapenned during cleanups
* **Return type:**
  list of Exception

# crash

### nmci.crash.check_dump_package(pkg_name)

Helper function to check if package name is relevant.

* **Parameters:**
  **pkg_name** (*ste*) – name of the package
* **Returns:**
  True if NetworkManager or ModemManager, False otherwise
* **Return type:**
  bool

### nmci.crash.check_crash(context, crashed_step)

Check if crash hapenned (by NM PID change), remember step when crash occured in context.

* **Parameters:**
  * **context** (*behave.Context*) – behave Context object
  * **crashed_step** (*str*) – Name of the crashed step

### nmci.crash.check_coredump(context)

Check for crashes reported to coredump

* **Parameters:**
  **context** (*behave.Context*) – behave Context object

### nmci.crash.coredump_is_reported(dump_id)

Check if crash is already reported, to not spam repeatedly the same crash.

* **Parameters:**
  **dump_id** (*str*) – unique ID of the crash, should differ across distinct crashes
* **Returns:**
  True if already reported, False otherwise
* **Return type:**
  bool

### nmci.crash.coredump_report(dump_id)

Save crash ID in cache, to be reported only once.

* **Parameters:**
  **dump_id** (*str*) – unique ID of the crash, should differ across distinct crashes

### nmci.crash.coredump_list_on_disk(dump_type=None)

List coredumps on disk.

* **Parameters:**
  **dump_type** (*obj**,* *optional*) – one of COREDUMP_TYPE_SYSTEMD_COREDUMP or COREDUMP_TYPE_ABRT, defaults to None
* **Returns:**
  list of filenames
* **Return type:**
  list of filename

### nmci.crash.wait_faf_complete(context, dump_dir)

Waits until given FAF is uploaded and reported correctly.

* **Parameters:**
  * **context** (*behave.Context*) – behave Context object
  * **dump_dir** (*ste*) – FAF dir to wait for
* **Returns:**
  True if wait succeded, False, if report still not complete
* **Return type:**
  bool

### nmci.crash.check_faf(context)

Check for new FAF reports

* **Parameters:**
  **context** (*behave.Context*) – behave COntext object

### nmci.crash.after_crash_reset()

Do the reset of NetworkManager config and envionment, to prevent NetworkManager crashing again.

# dbus

### nmci.dbus.bus_get(bus_type=None, cancellable=None)

Returns new bus

* **Parameters:**
  * **bus_type** (*Gio.BusType**,* *optional*) – type of the bus, defaults to None
  * **cancellable** (*Gio.Cancellable**,* *optional*) – cancellable object, defaults to None
* **Returns:**
  new bus
* **Return type:**
  Gio.Bus

### nmci.dbus.call(bus_name, object_path, interface_name, method_name, parameters=None, reply_type=None, flags=None, timeout_msec=None, bus_type=None, cancellable=None)

Call method on bus

* **Parameters:**
  * **bus_name** (*str*) – name of the bus
  * **object_path** (*str*) – path of the object
  * **interface_name** (*str*) – name of the bus interface
  * **method_name** (*str*) – name of the method to be called
  * **parameters** (*Gio.Variant**,* *optional*) – method parametrs, defaults to None
  * **reply_type** (*GLib.VariantType**,* *optional*) – type of the reply, defaults to None
  * **flags** (*Gio.DBusCallFlags**,* *optional*) – flags, defaults to Gio.DBusCallFlags.NONE
  * **timeout_msec** (*int**,* *optional*) – timeout for given call, defaults to None
  * **bus_type** (*Gio.BusType**,* *optional*) – type of bus, defaults to None
  * **cancellable** (*Gio.Cancellable**,* *optional*) – cancellable object, defaults to None
* **Returns:**
  returns method reply
* **Return type:**
  Glib.Variant

### nmci.dbus.get_all_properties(bus_name, object_path, interface_name, flags=None, timeout_msec=None, bus_type=None, cancellable=None)

Get all properties of given object

* **Parameters:**
  * **bus_name** (*str*) – name of the bus
  * **object_path** (*str*) – path of the object
  * **interface_name** (*str*) – name of the bus interface
  * **flags** (*Gio.DBusCallFlags**,* *optional*) – flags, defaults to Gio.DBusCallFlags.NONE
  * **timeout_msec** (*int**,* *optional*) – timeout for given call, defaults to None
  * **bus_type** (*Gio.BusType**,* *optional*) – type of bus, defaults to None
  * **cancellable** (*Gio.Cancellable**,* *optional*) – cancellable object, defaults to None
* **Returns:**
  returns method reply
* **Return type:**
  Glib.Variant

### nmci.dbus.get_property(bus_name, object_path, interface_name, property_name, reply_type=None, flags=None, timeout_msec=None, bus_type=None, cancellable=None)

Get property of given object

* **Parameters:**
  * **bus_name** (*str*) – name of the bus
  * **object_path** (*str*) – path of the object
  * **interface_name** (*str*) – name of the bus interface
  * **property_name** (*str*) – name of the property to get
  * **reply_type** (*GLib.VariantType**,* *optional*) – type of the reply, defaults to None
  * **flags** (*Gio.DBusCallFlags**,* *optional*) – flags, defaults to Gio.DBusCallFlags.NONE
  * **timeout_msec** (*int**,* *optional*) – timeout for given call, defaults to None
  * **bus_type** (*Gio.BusType**,* *optional*) – type of bus, defaults to None
  * **cancellable** (*Gio.Cancellable**,* *optional*) – cancellable object, defaults to None
* **Returns:**
  returns method reply
* **Return type:**
  Glib.Variant

### nmci.dbus.name_is_bus_name(name, check=False)

Check if given name is valid bus name

* **Parameters:**
  * **name** (*str*) – bus name
  * **check** (*bool**,* *optional*) – whether to raise if name is invalid, defaults to False
* **Raises:**
  **ValueError** – if name is invalid
* **Returns:**
  True if name is valid, False otherwise
* **Return type:**
  bool

### nmci.dbus.name_is_interface_name(name, check=False)

Check if given name is valid interface name

* **Parameters:**
  * **name** (*str*) – interface name
  * **check** (*bool**,* *optional*) – whether to raise if name is invalid, defaults to False
* **Raises:**
  **ValueError** – if name is invalid
* **Returns:**
  True if name is valid, False otherwise
* **Return type:**
  bool

### nmci.dbus.name_is_object_path(name, check=False)

Check if given name is valid object path

* **Parameters:**
  * **name** (*str*) – object path
  * **check** (*bool**,* *optional*) – whether to raise if path is invalid, defaults to False
* **Raises:**
  **ValueError** – if path is invalid
* **Returns:**
  True if path is valid, False otherwise
* **Return type:**
  bool

### nmci.dbus.object_path_norm(obj_path, default_prefix=None)

The D-Bus object paths is usually something like
“/org/freedesktop/NetworkManager/Devices/43”.

For convenience, allow obj_path to be only a number, in
which case default_prefix will be prepended.

* **Parameters:**
  * **obj_path** (*str*) – path of the object
  * **default_prefix** (*str**,* *optional*) – path prefix, if given object path is relative, defaults to None
* **Returns:**
  normalized object path
* **Return type:**
  str

# embed

### *class* nmci.embed.Embed(fail_only=False, combine_tag=None)

Bases: `object`

General Embed

* **Parameters:**
  * **fail_only** (*bool**,* *optional*) – whether to embed only if scenario failed, defaults to False
  * **combine_tag** (*str**,* *optional*) – join multiple embeds under single caption, defaults to None

#### *class* EmbedContext(count, embed_data)

Bases: `tuple`

Create new instance of EmbedContext(count, embed_data)

#### count

Alias for field number 0

#### embed_data

Alias for field number 1

#### evalDoEmbedArgs()

### *class* nmci.embed.EmbedData(caption, data, mime_type='text/plain', fail_only=False, combine_tag=None)

Bases: [`Embed`](#nmci.embed.Embed)

Embed General Data

* **Parameters:**
  * **caption** (*str*) – embed caption
  * **data** (*str*) – data to be embedded
  * **mime_type** (*str**,* *optional*) – mime-type of the data, defaults to “text/plain”
  * **fail_only** (*bool**,* *optional*) – whether to embed only if scenario failed, defaults to False
  * **combine_tag** (*str**,* *optional*) – join multiple embeds under single caption, defaults to None

### *class* nmci.embed.EmbedLink(caption, data, fail_only=False, combine_tag=None)

Bases: [`Embed`](#nmci.embed.Embed)

Embed links

* **Parameters:**
  * **caption** (*str*) – embed caption
  * **data** (*list* *of* *pairs* *of* *str*) – data must be a list of 2-tuples, where the first element, is the link target (href) and the second the text.
  * **fail_only** (*bool**,* *optional*) – whether to embed only if scenario failed, defaults to False
  * **combine_tag** (*str**,* *optional*) – join multiple embeds under single caption, defaults to None

### nmci.embed.after_scenario_finish(status)

This is needed as last call of `after_scenario()`
The purpose of this is to separate embeds between
scenarios correctly, provide status to the formatter
and formatter also computes time spend. It is harmless
when formatter is not using pseudo steps.

* **Parameters:**
  **status** (*str*) – status of the after scenario

### nmci.embed.after_step()

Sould be called after each step to refresh the combined tags.

### nmci.embed.before_scenario_finish(status)

This is needed as last call of `before_scenario()`
The purpose of this is to separate embeds between
scenarios correctly, provide status to the formatter
and formatter also computes time spend. It is harmless
when formatter is not using pseudo steps.

* **Parameters:**
  **status** (*str*) – status of the before scenario

### nmci.embed.embed_data(caption, data, mime_type='text/plain', fail_only=False, combine_tag=None, embed_context=None)

Embed General Data

* **Parameters:**
  * **caption** (*str*) – embed caption
  * **data** (*str*) – data to be embedded
  * **mime_type** (*str**,* *optional*) – mime-type of the data, defaults to “text/plain”
  * **fail_only** (*bool**,* *optional*) – whether to embed only if scenario failed, defaults to False
  * **combine_tag** (*str**,* *optional*) – join multiple embeds under single caption, defaults to None
  * **embed_context** (*EmbedContext object*) – context keeping counter and data, defaults to None

### nmci.embed.embed_dump(caption, dump_id, \*, data=None, links=None)

embed new crash dump

* **Parameters:**
  * **caption** (*str*) – embed caption
  * **dump_id** (*str*) – unique ID of the crash
  * **data** (*str**,* *optional*) – backtrace of the coredump, defaults to None
  * **links** (*list* *of* *pairs* *of* *str**,* *optional*) – FAF links to embed, defaults to None

### nmci.embed.embed_file_if_exists(caption, fname, as_base64=False, fail_only=False)

Embed file to HTML report

* **Parameters:**
  * **caption** (*str*) – embed caption
  * **fname** (*str*) – name of the file to embed
  * **as_base64** (*bool**,* *optional*) – whether to convert file to base64, defaults to False
  * **fail_only** (*bool**,* *optional*) – wheter to embed only if scenario fails, defaults to True
* **Returns:**
  True if file exists and embedded, False otherwise
* **Return type:**
  bool

### nmci.embed.embed_link(caption, data, fail_only=False, combine_tag=None, embed_context=None)

Embed links

* **Parameters:**
  * **caption** (*str*) – embed caption
  * **data** (*list* *of* *pairs* *of* *str*) – data must be a list of 2-tuples, where the first element, is the link target (href) and the second the text.
  * **fail_only** (*bool**,* *optional*) – whether to embed only if scenario failed, defaults to False
  * **combine_tag** (*str**,* *optional*) – join multiple embeds under single caption, defaults to None
  * **embed_context** (*EmbedContext object*) – context keeping counter and data, defaults to None

### nmci.embed.embed_run(argv, shell, returncode, stdout, stderr, fail_only=True, embed_context=None, combine_tag=<object object>, elapsed_time=None)

Embed results of a process

* **Parameters:**
  * **argv** (*list* *of* *str* *or* *str*) – arguments of the process
  * **shell** (*bool*) – whether executed in shell
  * **returncode** (*int*) – returncode of the process
  * **stdout** (*str* *or* *binary*) – STDOUT of the process
  * **stderr** (*str* *or* *binary*) – STDERR of the process
  * **fail_only** (*bool**,* *optional*) – wheter to embed only if scenario fails, defaults to True
  * **embed_context** (*Embed.EmedContext**,* *optional*) – embed context, defaults to None
  * **combine_tag** (*str**,* *optional*) – caption of joined embeds, defaults to TRACE_COMBINE_TAG, computes caption from stactrace
  * **elapsed_time** (*float**,* *optional*) – measured time of process run in seconds, defaults to None

### nmci.embed.embed_service_log(descr, service=None, syslog_identifier=None, journal_args=None, cursor=None, fail_only=False)

Embed log of service using journalctl

* **Parameters:**
  * **descr** (*str*) – embed caption
  * **service** (*str**,* *optional*) – name of the service to filter out, defaults to None
  * **syslog_identifier** (*str**,* *optional*) – equivalent to ‘-u’ parameter of journalctl, defaults to None
  * **journal_args** (*list* *of* *str**,* *optional*) – additional journalctl arguments, defaults to None
  * **cursor** (*str**,* *optional*) – journalctl cursor, defaults to None
  * **fail_only** (*bool**,* *optional*) – wheter to embed only if scenario fails, defaults to True

### nmci.embed.formatter_add_scenario(scenario)

Register the scenario in formatter.

This is called if skipped before scenario, because behave then does not
register the scenario to formatter.

* **Parameters:**
  **scenario** (*behave.Scenario*) – scenario to be registered in formatter

### nmci.embed.get_current_scenario()

Returns the current scenario object of the HTML formatter

* **Returns:**
  current scenario object in HTML formatter
* **Return type:**
  formatter.Scenario

### nmci.embed.get_embed_context(combine_tag)

Returns the EmbedContext object for given combine tag, creates new if needed.

* **Parameters:**
  **combine_tag** (*str*) – caption of joined embeds
* **Returns:**
  EmbedContext object for given combine_tag.
* **Return type:**
  [EmbedContext](#nmci.embed.Embed.EmbedContext)

### nmci.embed.has_html_formatter()

Check if HTML formatter is set. This makes sense only after setup() call.

* **Returns:**
  True if HTML formatter is present.
* **Return type:**
  bool

### nmci.embed.is_faf_reported()

Whether FAF report was embedded or not.

* **Returns:**
  True if FAF was embedded, False otherwise
* **Return type:**
  bool

### nmci.embed.process_embeds()

This is called in after scenario to process the embeds
and send data to the HTML formatter (if present).

### nmci.embed.set_title(\*a, \*\*kw)

Calls set_title() of the formatter, if supported by formatter.

### nmci.embed.setup(runner)

Save formatter from behave.Runnr object

* **Parameters:**
  **runner** (*behave.Runner*) – behave Runner object

# git

### nmci.git.config_get_origin_url()

Return git origin URL, converted to HTTPS.
This is cached, `git` is called at most once per run.

* **Returns:**
  git origin URL as HTTPS
* **Return type:**
  str

### nmci.git.rev_parse(rev)

Return commit hash for given revision.
This is cached, `git` is called at most once per run.

* **Parameters:**
  **rev** (*str*) – git revision (e.g. ‘HEAD’, ‘HEAD~7’ or branch name)
* **Raises:**
  **Exception** – If git command fails
* **Returns:**
  commit hash
* **Return type:**
  str

# gsm

### nmci.gsm.reset_usb_devices()

Resets USB GSM devices

### nmci.gsm.reinitialize_devices()

Reinitialize GSM devices

### nmci.gsm.find_modem()

Find the 1st modem connected to a USB port or USB hub on a testing machine.

When to extract information about a modem?
- When the modem is initialized.
- When it is available in the output of  `mmcli -L`.
- When the device has type of `'gsm'` in the output of `nmcli dev`.

* **Returns:**
  detected modem specified in a dictionary
* **Return type:**
  str

### nmci.gsm.get_modem_info(context)

Get a list of connected modem via command `mmcli -L`.
Extract the index of the 1st modem.
Get info about the modem via command `mmcli -m $i`
Find its SIM card. This optional for this function.
Get info about the SIM card via command `mmcli --sim $i`.

* **Returns:**
  modem information
* **Return type:**
  str

# ip

### nmci.ip.addr_family_check(addr_family)

Check that address family is `socket.AF_INET` or `socket.AF_INET6`.

* **Parameters:**
  **addr_family** (*socket.AddressFamily*) – address family
* **Raises:**
  **ValueError** – when invalid address family provided

### nmci.ip.addr_family_norm(addr_family)

Normalize address family.

* **Parameters:**
  **addr_family** (*socket.AddressFamily* *or* *string*) – address family
* **Returns:**
  socket constant or None
* **Return type:**
  socket.AddressFamily

### nmci.ip.addr_family_num(addr_family, allow_none=False)

Number represenation (4 or 6) of address family.

* **Parameters:**
  * **addr_family** (*socket.AddressFamily* *or* *string*) – address family
  * **allow_none** (*bool**,* *optional*) – whether to accept None value, defaults to False
* **Returns:**
  number representation of address family
* **Return type:**
  int

### nmci.ip.addr_family_plen(addr_family)

IP address length for given family

* **Parameters:**
  **addr_family** (*socket.AddressFamily* *or* *str*) – address family
* **Returns:**
  length of address
* **Return type:**
  int

### nmci.ip.address_add(address, ifname=None, \*, ifindex=None, wait_for_device=None, addr_family=None, namespace=None)

Add IP address to interface.

* **Parameters:**
  * **address** (*str*) – IP address to add
  * **ifname** (*str**,* *optional*) – interafce name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interafce index, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout for device to appear, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None

### nmci.ip.address_expect(expected, ifindex=None, ifname=None, match_mode='auto', with_plen=False, ignore_order=False, ignore_extra=True, addr_family=None, wait_for_address=None, addrs=None, namespace=None)

Check if expected address is present on interface.

* **Parameters:**
  * **expected** (*list* *of* *str* *or* *re.Pattern*) – list of expected addresses
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
  * **match_mode** (*str**,* *optional*) – see `nmci.util.compare_strv_list`, defaults to “auto”
  * **with_plen** (*bool**,* *optional*) – whether to strip prefix or not, defaults to False
  * **ignore_order** (*bool**,* *optional*) – whether to ignore address order, defaults to False
  * **ignore_extra** (*bool**,* *optional*) – whether to addresses must match exactly, defaults to True
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **wait_for_address** (*float**,* *optional*) – timeout until address must be present, defaults to None
  * **addrs** (*dict**,* *optional*) – addreses, if set will not query `address_show()`, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
* **Returns:**
  adresses of the matched interfaces
* **Return type:**
  dict

### nmci.ip.address_flush(ifname=None, \*, ifindex=None, wait_for_device=None, addr_family=None, namespace=None)

Flush addresses on given interface.

* **Parameters:**
  * **ifname** (*str**,* *optional*) – interafce name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interafec index, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout until device appears, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None

### nmci.ip.address_show(binary=None, ifindex=None, ifname=None, addr_family=None, atype=None, namespace=None)

Get addresses via `ip address show`. Possibility to filter output
by providing ifindex or ifname.

* **Parameters:**
  * **binary** (*bool**,* *optional*) – whether to return bytes, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – index of interface to show, defaults to None
  * **ifname** (*\_type_**,* *optional*) – interafce name to show, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **atype** (*str**,* *optional*) – output only addresses of the following type, one of “inet”, “inet6”, “link/ether”, defaults to None
  * **namespace** (*str**,* *optional*) – namespace to match, defaults to None
* **Returns:**
  addresses for matched inetrafces
* **Return type:**
  dict

### nmci.ip.ipaddr_norm(s, addr_family=None)

Normalize IP address. If address family is not provided
both IPv4 and IPv6 addresses are accepted.

* **Parameters:**
  * **s** (*str* *or* *bytes*) – address
  * **addr_family** (*socket.AddressFamily* *or* *str* *or* *None**,* *optional*) – address family, defaults to None
* **Returns:**
  normalized address
* **Return type:**
  str

### nmci.ip.ipaddr_parse(s, addr_family=None)

Parse IP address from string. If address family is not provided
both IPv4 and IPv6 addresses are accepted.

* **Parameters:**
  * **s** (*str* *or* *bytes*) – address
  * **addr_family** (*socket.AddressFamily* *or* *str* *or* *None**,* *optional*) – address family, defaults to None
* **Returns:**
  normalized address with detected address family
* **Return type:**
  tuple, str and socket.AddressFamily

### nmci.ip.ipaddr_plen_norm(s, addr_family=None)

Normalize IP address and prefix. If address family is not provided
both IPv4 and IPv6 addresses are accepted.

* **Parameters:**
  * **s** (*str* *or* *bytes*) – address with prefix, e.g “1.2.3.4/31”
  * **addr_family** (*socket.AddressFamily* *or* *str* *or* *None**,* *optional*) – address family, defaults to None
* **Raises:**
  **ValueError** – when provided address or plen is invalid
* **Returns:**
  normalized adrress with prefix
* **Return type:**
  str

### nmci.ip.ipaddr_plen_parse(s, addr_family=None)

Parse IP address and prefix from string. If address family is not provided
both IPv4 and IPv6 addresses are accepted.

* **Parameters:**
  * **s** (*str* *or* *bytes*) – address with prefix, e.g “1.2.3.4/31”
  * **addr_family** (*socket.AddressFamily* *or* *str* *or* *None**,* *optional*) – address family, defaults to None
* **Raises:**
  **ValueError** – when provided address or plen is invalid
* **Returns:**
  tuple of normalized address, address family and prefix
* **Return type:**
  tuple, str and socket.AddressFamily and int

### nmci.ip.ipaddr_zero(addr_family)

Zero address for given address family

* **Parameters:**
  **addr_family** (*socket.AddressFamily* *or* *string*) – address family
* **Returns:**
  “0.0.0.0” or “::”
* **Return type:**
  str

### nmci.ip.link_add(ifname, link_type, \*args, ifindex=None, namespace=None, wait_for_device=None, \*\*kwargs)

Add new link. Additional arguments are appended to
`ip link add ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.

* **Parameters:**
  * **ifname** (*str*) – interface name
  * **link_type** (*str*) – interface type
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout until device appears, defaults to None

### nmci.ip.link_delete(ifname=None, \*, ifindex=None, accept_nodev=False, namespace=None)

Delete link.

* **Parameters:**
  * **ifname** (*str**,* *optional*) – interafce name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **accept_nodev** (*bool**,* *optional*) – whether to raise if device already not present, defaults to False
  * **namespace** (*str**,* *optional*) – namespace, defaults to None

### nmci.ip.link_set(ifname=None, \*args, ifindex=None, up=None, wait_for_device=None, namespace=None, name=None, netns=None, master=None, \*\*kwargs)

Set link attributes. Additional arguments are appended to
`ip link set ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.

* **Parameters:**
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **up** (*bool**,* *optional*) – if set, interface is set `up` or `down`, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout for device to appear, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
  * **name** (*str**,* *optional*) – new name for interface, defaults to None
  * **netns** (*str**,* *optional*) – new namespace for interface, defaults to None
  * **master** (*str**,* *optional*) – new master of interface, defaults to None

### nmci.ip.link_show(ifname=None, \*, timeout=None, \*\*kwargs)

Show single link. Interface name or index must be provided.

* **Parameters:**
  * **timeout** (*float**,* *optional*) – timeout until device must appear, defaults to None
  * **ifname** (*str**,* *optional*) – interafce name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **flags** (*str**,* *optional*) – interafce has to have given flags, defaults to None
  * **binary** (*bool**,* *optional*) – see `link_show_all()`, defaults to None
  * **allow_missing** (*bool**,* *optional*) – does not raise Exception if none interafce matched, defaults to False
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
* **Returns:**
  attributes of matched interafce or None
* **Return type:**
  dict

### nmci.ip.link_show_all(binary=None, namespace=None)

Show all links. Parameter binary can be:

`False`: expect all stings to be UTF-8, the result only contains decoded strings
`True`: expect at least some of the names to be binary, all the ifnames are bytes
`None`: expect a mix. The ifnames that can be decoded as UTF-8 are returned as strings, otherwise as bytes.

* **Parameters:**
  * **binary** (*bool**,* *optional*) – whether output should be string or binary or mixed, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
* **Returns:**
  Attributes of all availiable links
* **Return type:**
  dict

### nmci.ip.link_show_maybe(ifname=None, \*, allow_missing=True, \*\*kwargs)

Show single link. Interface name or index must be provided.

* **Parameters:**
  * **timeout** (*float**,* *optional*) – timeout until device must appear, defaults to None
  * **ifname** (*str**,* *optional*) – interafce name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **flags** (*str**,* *optional*) – interafce has to have given flags, defaults to None
  * **binary** (*bool**,* *optional*) – see `link_show_all()`, defaults to None
  * **allow_missing** (*bool**,* *optional*) – does not raise Exception if none interafce matched, defaults to True
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
* **Returns:**
  attributes of matched interafce or None
* **Return type:**
  dict

### nmci.ip.mac_aton(mac_str, force_len=None)

Convert MAC address to bytes.
We also accept None and ‘’ for convenience, None yiels None, ‘’ yields [].

* **Parameters:**
  * **mac_str** (*str*) – mac address
  * **force_len** (*int**,* *optional*) – length of address in bits, defaults to None
* **Returns:**
  MAC address in bytes
* **Return type:**
  bytes

### nmci.ip.mac_norm(mac_str, force_len=None)

Normalize MAC address string.
We also accept None and ‘’ for convenience, None yiels None, ‘’ yields [].

* **Parameters:**
  * **mac_str** (*str*) – mac address
  * **force_len** (*int**,* *optional*) – length of address in bits, defaults to None
* **Returns:**
  normalized MAC address
* **Return type:**
  str

### nmci.ip.mac_ntoa(mac)

Convert bytes to MAC address string

* **Parameters:**
  * **mac_str** (*str*) – mac address
  * **force_len** (*int**,* *optional*) – length of address in bits, defaults to None
* **Returns:**
  MAC address
* **Return type:**
  str

### nmci.ip.netns_add(name, cleanup=True)

Add namespace

* **Parameters:**
  * **name** (*str*) – name if the namespace
  * **cleanup** (*bool*) – whether to clean up the namespace after scenario. Defaults to True

### nmci.ip.netns_delete(name, check=True)

Delete namespace

* **Parameters:**
  * **name** (*str*) – name of namespace
  * **check** (*bool**,* *optional*) – whether to raise if namespace already deleted, defaults to True

### nmci.ip.netns_list(with_binary=False)

List availiable namespaces.

* **Parameters:**
  **with_binary** (*bool**,* *optional*) – whether to return as bytes, defaults to False
* **Returns:**
  list of interface names
* **Return type:**
  list of str

### nmci.ip.route_add(route, ifname=None, \*args, ifindex=None, addr_family=None, namespace=None, wait_for_device=None, \*\*kwargs)

Add route.  Additional arguments are appended to
`ip route ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.

* **Parameters:**
  * **route** (*str*) – route, address and prefix or `'default'`
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout until device appears, defaults to None

### nmci.ip.route_del(route, ifname=None, \*args, ifindex=None, namespace=None, addr_family=None, wait_for_device=None, \*\*kwargs)

Delete route.  Additional arguments are appended to
`ip route ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.

* **Parameters:**
  * **route** (*str*) – route, address and prefix or `'default'`
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout until device appears, defaults to None

### nmci.ip.route_flush(ifname=None, ifindex=None, namespace=None, wait_for_device=None, addr_family=None)

Flush routes.

* **Parameters:**
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout until device appears, defaults to None

### nmci.ip.route_show(ifname=None, ifindex=None, namespace=None, wait_for_device=None, addr_family=None)

Show routes. Returned in dictionary, where keys are routes (address with prefix)
and value is additinal arguments (allowing simple checks: `'1.2.3.4/10' in route_show()`)
TODO will not work if multiple route is having different options.

* **Parameters:**
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
  * **ifindex** (*int* *or* *str**,* *optional*) – interface index, defaults to None
  * **addr_family** (*socket.AddressFamily* *or* *str**,* *optional*) – address family, defaults to None
  * **namespace** (*str**,* *optional*) – namespace, defaults to None
  * **wait_for_device** (*float**,* *optional*) – timeout until device appears, defaults to None
* **Returns:**
  routes in dictionary, keyword is route address with prefix, value additional argument.

# misc

### *exception* nmci.misc.HitRaceException

Bases: `Exception`

Exception to be thrown, when some race condition is hit.

### *exception* nmci.misc.InvalidTagsException

Bases: `Exception`

Exception to be thrown, when some invalid tags are detected.

### *exception* nmci.misc.SkipTestException

Bases: `Exception`

Exception to be thrown when test shoud be skipped, to prevent further code execution.

### *exception* nmci.misc.TestNotFoundException

Bases: `Exception`

Exception to be thrown when test is not found.

### nmci.misc.distro_detect(use_cached=True)

Get distribution name and version.

* **Parameters:**
  **use_cached** (*bool**,* *optional*) – whether to use already processed version, defaults to True
* **Returns:**
  distribution name and numerical version
* **Return type:**
  tuple of string and list of int

### nmci.misc.format_dict(values, connector=' = ', separator=', ')

Universal dictionary formatter.

* **Parameters:**
  * **values** (*dict*) – dictionary to format
  * **connector** (*str**,* *optional*) – string that connects a key with its value, defaults to “ = “
  * **separator** (*str**,* *optional*) – string that separates key,value pairs, defaults to “, “
* **Returns:**
  string containing fomratted dictionary
* **Return type:**
  str

### nmci.misc.format_duration(seconds)

Format duration in seconds to 3 decimal places and append `'s'`.

* **Parameters:**
  **seconds** (*float*) – number of seconds
* **Returns:**
  string containg formatted duration
* **Return type:**
  str

### nmci.misc.get_dns_info(dns_plugin, ifindex=None, ifname=None)

Get DNS interface info. At least one of ifindex and ifname must be set.

* **Parameters:**
  * **dns_plugin** (*str*) – one of `systemd-resolved` or `dnsmasq`
  * **ifindex** (*int* *or* *str**,* *optional*) – interfave index, defaults to None
  * **ifname** (*str**,* *optional*) – interface name, defaults to None
* **Returns:**
  dns information
* **Return type:**
  dict

### nmci.misc.get_mapper_obj()

Loads mapper as python object (dict). Yaml loader is significantly slower
than json. Since this is called multiple times per test, we convert yaml
to json cache. Json cache is not used if it does not exists or yaml file has
newer modification timestamp.

* **Returns:**
  mapper
* **Return type:**
  dict

### nmci.misc.get_mapper_tests(mapper, feature='\*', testmapper='\*')

Get all tests from mapper. Possible to filter specific feature or testmapper.

* **Parameters:**
  * **mapper** (*dict*) – mapper object
  * **feature** (*str**,* *optional*) – name of the feature, defaults to “\*”
  * **testmapper** (*str**,* *optional*) – name of the testmapper, defaults to “\*”
* **Returns:**
  list of the tests with attributes
* **Return type:**
  list of dict

### nmci.misc.html_report_file_links()

Convert filenames in HTML report to links to gitlab.

### nmci.misc.html_report_tag_links()

Convert tags in HTML report to links to gitlab.

### nmci.misc.journal_get_cursor()

Get journalctl cursor, which can be used with argument `--after`

* **Returns:**
  journalctl cursor
* **Return type:**
  str

### nmci.misc.journal_send(msg: str, prefix: str = '<nmci> ', priority: int = 6, MESSAGE_ID='c93c2505-a0c5-4e26-9053-7c889d59a3de', SYSLOG_IDENTIFIER='nmci', \*\*kw)

A convenience wrapper around from systemd.journal.send() Unrecognized
keyword arguments are passed to send() as-is to be recorded as
eponymous journal fields.

* **Parameters:**
  * **msg** – A message to be logged to jounal
  * **prefix** – The message will be prefixed by this (by default: ‘<nmci> ‘)
  * **priority** – syslog priority. By default journal.LOG_INFO == 6
  * **MESSAGE_ID** – sets journal MESSAGE_ID to given value. By default: c93c2505-a0c5-4e26-9053-7c889d59a3de
  * **SYSLOG_IDENTIFIER** – identifier allowing to retrieve the messages from
    journal by specifiying ‘-t ID’ or ‘SYSLOG_IDENTIFIER=ID’. Defaults to ‘nmci’

### nmci.misc.journal_show(service=None, \*, syslog_identifier=None, cursor=None, short=False, journal_args=None, as_bytes=False, max_size=None, warn_max_size=True, prefix=None, suffix=None)

Get journal messgages satisfying the filters.

* **Parameters:**
  * **service** (*str**,* *optional*) – shown only messages of this service, journalctl argument `-u`, defaults to None
  * **syslog_identifier** (*str**,* *optional*) – shown only messages of this identifier, journalctl argument `-t`, defaults to None
  * **cursor** (*str**,* *optional*) – show only messages newer than cursor, defaults to None
  * **short** (*bool**,* *optional*) – shrot output format, defaults to False
  * **journal_args** (*str* *or* *list* *of* *str**,* *optional*) – additional `journalctl` arguments, defaults to None
  * **as_bytes** (*bool**,* *optional*) – wether return bytes instead of str, defaults to False
  * **max_size** (*int**,* *optional*) – limit the size of output in bytes, if None then 50Mb, defaults to None
  * **warn_max_size** (*bool**,* *optional*) – only show warning if max_size exceeded, do not raise, defaults to True
  * **prefix** (*str* *or* *bytes**,* *optional*) – message placed before actual journal output, defaults to None
  * **suffix** (*str* *or* *bytes**,* *optional*) – message placed before actual journal output, defaults to None
* **Returns:**
  filtered journal messages
* **Return type:**
  str

### nmci.misc.list_to_intervals(numbers)

Converts list of sorted numbers to string containing intervals.
Example: [1,2,4,5,6,7,10] -> “1,2,4..7,10”

* **Parameters:**
  **numbers** – list of numbers to convert
* **Returns:**
  string containing formatted list
* **Return type:**
  str

### nmci.misc.nm_version_detect(use_cached=True)

Get parsed NetworkManager version. If environment variable `NM_VERSION`
is set, it is used instead of getting version by `NetworkManager -v`.

* **Parameters:**
  **use_cached** (*bool**,* *optional*) – whether to use already processed version, defaults to True
* **Returns:**
  parsed version returned by `nm_version_parse()`
* **Return type:**
  tuple of string and list of int

### nmci.misc.nm_version_parse(version)

Parses the version string from `/sbin/NetworkManager -V` and detects a version
array and a stream string.

In particular, the stream is whether this is a package from upstream or from
dist-git (fedora/fedpkg or rhel/rhpkg).

Since a package build for e.g. rhel-8.3 always has the suffix .el8, we cannot
use that reliably to detect the stream. Well, we can, but all el8 packages
that are not actually “rhel-8” stream, must have a unique version tag.
Like for example copr builds of upstream have.

* **Parameters:**
  **version** (*str*) – version
* **Raises:**
  **ValueError** – when unable to parse version
* **Returns:**
  tuple of stream and version as list of ints
* **Return type:**
  tuple of string and list of int

### nmci.misc.nmlog_parse_dnsmasq(ifname)

Return dnsmasq log as python object/dict.
Executes [`nmci/helpers/nmlog-parse-dnsmasq.sh`](nmci/helpers/nmlog-parse-dnsmasq.sh)

* **Parameters:**
  **ifname** (*str*) – interafce name
* **Returns:**
  parsed logs
* **Return type:**
  dict

### nmci.misc.str_replace_dict(text, values, dict_name='noted')

Render templated text with values from dictionary. Can be used to
inplace `context.noted` into the string.

Examples:

`Hello <noted:name>!!!`

if provided with `{'name':'world'}`, result will be

`Hello world!!!`

dict_name controls prefix of what is being replaced, if set to `env`:

`Hello <env:here>!!!`

will be converted to `Hello there!!` if provided with `{'here':'there'}`

This allows replacement by independent dicts without need of
combining the dictionary into one and solving conflits.

* **Parameters:**
  * **text** (*str*) – template text
  * **values** (*str*) – dictionary containing values in template
  * **dict_name** (*str**,* *optional*) – prefix in template we replace, defaults to “noted”
* **Returns:**
  rendered text
* **Return type:**
  str

### nmci.misc.test_find_feature_file(test_name, feature='\*')

Return feature filename for given test name, gets data from `mapper.yaml`
to prevent parsing all the feature files.

* **Parameters:**
  * **test_name** (*str*) – tag name of the test
  * **feature** (*str**,* *optional*) – feature name, to narrow th search, defaults to “\*”
* **Returns:**
  feature filename
* **Return type:**
  str

### nmci.misc.test_get_feature_files(feature='\*')

Get list of feature files,

* **Parameters:**
  **feature** (*str**,* *optional*) – feature name, will interpret ‘\*’, defaults to “\*”
* **Returns:**
  list of filenames
* **Return type:**
  list of str

### nmci.misc.test_load_tags_from_features(feature=None, test_name=None, feature_file=None)

Load test tags from feature.

* **Parameters:**
  * **feature** (*str**,* *optional*) – name of the featue, defaults to None
  * **test_name** (*str**,* *optional*) – tag name of the test, defaults to None
  * **feature_file** (*str**,* *optional*) – filename of the feature file, defaults to None
* **Returns:**
  list of tags of the tests
* **Return type:**
  list of list of str

### nmci.misc.test_load_tags_from_file(filename, test_name=None)

Load tags from feature file.

We memoize the result of the parsing. Feel free to
`delattr(self, "_test_load_tags_from_file_cache")` to
prune the cache.

* **Parameters:**
  * **filename** (*str*) – feature file name
  * **test_name** (*str**,* *optional*) – tag name of the test, defaults to None
* **Returns:**
  list of test tags
* **Return type:**
  list of list of str

### nmci.misc.test_name_normalize(test_name)

Normalize testname, raise if invalid characters are contained.

* **Parameters:**
  **test_name** (*str*) – name of the test
* **Raises:**
  **ValueError** – when name is invalid
* **Returns:**
  normalized name of the test
* **Return type:**
  str

### nmci.misc.test_tags_match_version(test_tags, nm_version_info, distro_version_info)

Check if tags match the versions of NetworkManager and distro

* **Parameters:**
  * **test_tags** (*list* *of* *string*) – all tags for given test
  * **nm_version_info** (*tuple* *of* *string and list* *of* *int*) – parsed NetworkManager version `(stream, version)`
  * **distro_version_info** (*tuple* *of* *string and list* *of* *int*) – parsed distro version `(flavor, version)`
* **Returns:**
  test_tags if they match versions, None otherwise
* **Return type:**
  list of string

### nmci.misc.test_tags_select(test_tags_list, nm_version_info, distro_version_info)

Picks the test that satisfies the versions.

* **Parameters:**
  * **test_tags_list** (*list* *of* *list* *of* *str*) – list of tests (test is list of tags)
  * **nm_version_info** (*tuple* *of* *string and list* *of* *int*) – parsed NetworkManager version `(stream, version)`
  * **distro_version_info** (*tuple* *of* *string and list* *of* *int*) – parsed distro version `(flavor, version)`
* **Raises:**
  * **self.InvalidTagsException** – when multiple tests matches
  * **self.SkipTestException** – when none test is matched
* **Returns:**
  tags of the matched test
* **Return type:**
  list of string

### nmci.misc.test_version_check(test_name, feature='\*')

This is called by version control [`nmci/helpers/version_control.py`](nmci/helpers/version_control.py)

this checks for tests with given tag and returns all tags of the first test satisfying all conditions

this parses tags: `ver{-,+,-=,+=}, rhelver{-,+,-=,+=}, fedoraver{-,+,-=,+=}, [not_with_]rhel_pkg, [not_with_]fedora_pkg`.

{rhel,fedora}ver tags restricts only their distros, so rhelver+=8 runs on all Fedoras, if fedoraver not restricted
to not to run on rhel / fedora use tags rhelver-=0 / fedoraver-=0 (or something similar)

`{rhel,fedora}_pkg means` to run only on stock RHEL/Fedora package
`not_with_{rhel,fedora}_pkg` means to run only on daily build (not patched stock package)
similarly, `*_pkg` restricts only their distros, `rhel_pkg` will run on all Fedoras (build and stock pkg)

since the first satisfying test is returned, the last test does not have to contain distro restrictions
and it will run only in remaining conditions - so order of the tests matters in this case

* **Parameters:**
  * **test_name** (*str*) – tag name of the test
  * **feature** (*str**,* *optional*) – name of the feature, defaults to “\*”
* **Returns:**
  feature filename and testname and list of all test tags
* **Return type:**
  tuple of str and str and list of str

### nmci.misc.test_version_tag_eval(ver_tags, version)

This is how we interpret the “ver+”/”ver-” version tags.
This scheme makes sense for versioning schemes where we have a main
branch (where major releases get tagged) and stable branches (with
minor releases). This is the versioning scheme of NetworkManager
(“ver” tag) but it also works for “rhelver”/”fedoraver”.

Currently it only supports a main branch (with major releases)
and stable branches (with minor releases) that branch off the
main branch. It does not support a second level of bugfix branches
that branch off stable branches, but that could be implemented too.

Notes:

1) the version tags ‘-‘/’+’ are just convenience forms of ‘-=’/’+=’. They
need no special consideration (“+1.28.5” is exactly the same as “+=1.28.6”).

2) if both ‘-=’ and ‘+=’ are present, they might either define single closed range
e.g. “ver+=1.26, ver-=1.30”, or a “hole” (buggy interval), e.g. “ver-=1.26, ver+=1.30”.

3) version tags can either specify the full version (“ver+=1.26.4”) or only the major
component (“ver+=1.27”).
Of all the version tags of the same ‘+’/’-’ group, the shortest and highest one also
determines the next major version.
For example, with “ver+=1.26.4, ver+=1.28.2” both tags have 3 components (they
both are the “shortest”). Of these, “ver+=1.28.2” is the highest one. From that we
automatically also get “ver+=1.29[.0]” and ver+=2[.0.0]”.
This means, if you specify the latest stable version (1.28.2) that introduced a feature,
then automatically all newer major versions are covered.
Basically, the shortest and highest tag determines the major branch. If you have
more tags of the same ‘+’/’-’ type, then those are only for the stable branch.
With example “ver+=1.26.4, ver+=1.28.2”, the first tag only covers 1.26.4+ stable
versions, nothing else.

4) for each ‘+’ version tag that comes right after ‘+’ version tag (when sorted ascending),
there is added ‘-’ tag, keeping only first 2 parts of version:
- “ver+=1.28.6 ver+=1.30.1” is equivalent to “ver+=1.28.6 ver-1.30 ver+=1.30.1”
meaning, that 1.29.x is satisfied, but 1.30.0 is skipped

5) for each ‘-’ version tag that comes right before ‘-’ version tag (when sorted ascending),
there is added ‘+’ tag keeping only first 2 parts of version and adding “9999.9999” :
- “ver-=1.28.6 ver-=1.30.1” is equivalent to “ver-=1.28.6 ver+1.28.9999.9999 ver-=1.30.1”

* **Parameters:**
  * **ver_tags** (*list* *of* *tuple* *of* *string and list* *of* *int*) – parsed version tags of the test in form of `(operation, version)`
  * **version** (*list* *of* *int*) – parsed version to compare (of NetworkManager or distro)
* **Returns:**
  whether the version satisfy conditions prescribed by tags
* **Return type:**
  bool

### nmci.misc.test_version_tag_filter_for_stream(tags_ver, nm_stream)

This function now returns a list of (op,version) tuple, but only selecting
those that have a matching stream… that means, if the nm_stream is
“rhel-8-10”, then:

> - if exist, it will return all tags_ver with stream `["rhel", "8", "10"]`
> - if exist, it will return all tags_ver with stream `["rhel", "8"]`
> - if exist, it will return all tags_ver with stream `["rhel"]`
> - if exist, it will return all tags_ver with stream `[]`

With this scheme, you can have a default version tag that always matches (`@ver+=1.39`),
but you can override it for rhel (`@ver/rhel+=x`) or even for rhel-8 only (`@ver/rhel/8+=x`)

* **Parameters:**
  * **tags_ver** (*tuple* *of* *string and string and list* *of* *ints*) – list of version tags parsed by `test_version_tag_parse_ver()` (it contains a 3-tuple of (stream, op, version)
  * **nm_stream** (*str*) – the stream detected by `nm_version_parse()`, for example `rhel-8-10` or `fedora-33`
* **Returns:**
  filtered versions with matching stream
* **Return type:**
  list of tuple of string and list of int

### nmci.misc.test_version_tag_parse(version_tag, tag_candidate)

Parse version tag into operator and version, given that prefix is preparsed.

* **Parameters:**
  * **version_tag** (*str*) – version tag
  * **tag_candidate** (*str*) – prefix of the version tag (e.g. `'ver'` or `'ver/rhel/8'`)
* **Returns:**
  tuple of operator and version as list of int
* **Return type:**
  tuple of str and list of int

### nmci.misc.test_version_tag_parse_ver(version_tag)

This parses tags in the form @ver$STREAM$OP$VERSION where

- $STREAM is for example “”, “/upstream”, “/fedora”, “/fedora/33”, “/rhel”, “/rhel/8”. It matches
  the stream returned by nm_version_parse().
- $OP is the comparison operator (“-”, “-=”, “+”, “+=”)
- $VERSION is the version number to compare. Corresponds the version returned by `nm_version_parse()`.

* **Parameters:**
  **version_tag** (*str*) – version tag
* **Raises:**
  **ValueError** – if version tag is invalid
* **Returns:**
  tuple of stream and operator and version
* **Return type:**
  tuple of string and string and list of ints

### nmci.misc.ver_param_to_str(nm_stream, nm_version, distro_flavor, distro_version)

String represenation of parsed NetworkManager and distro version

* **Parameters:**
  * **nm_stream** (*str*) – NetworkManager stream
  * **nm_version** (*list* *of* *int*) – NetworkManager version
  * **distro_flavor** (*str*) – distribution flavor name
  * **distro_version** (*list* *of* *int*) – distribution version
* **Returns:**
  formatted arguments, versions are dot separated integers `nm_stream:nm_version (distro_flavor:distro_version)`
* **Return type:**
  str

# nmutil

### nmci.nmutil.connection_show(\*, only_active=False, without_active_externally=False, name=None, uuid=None, setting_type=None)

Call `nmcli connection show` to get a list of profiles. It augments
the result with directly fetched data from D-Bus (the fetched data
is thus not in sync with the data fetched with the nmcli call).

An alternative might be to use NMClient, which works hard to give
a consistent result from one moment (race-free). That is not done
here, but it also would be a different functionality.

* **Parameters:**
  * **only_active** (*bool**,* *optional*) – only show active connections, defaults to False
  * **without_active_externally** (*bool**,* *optional*) – only show active connections that are not activated externally, defaults to False
  * **name** (*str**,* *optional*) – only show connections with this name, defaults to None
  * **uuid** (*str**,* *optional*) – only show connections with this UUID, defaults to None
  * **setting_type** (*str**,* *optional*) – only show connections with this type, defaults to None
* **Returns:**
  list of connections
* **Return type:**
  list

### nmci.nmutil.context_get_nm_stopped(context=None)

Gets context.nm_stopped, which indicates that NetworkManager
service was stopped during the test.

* **Parameters:**
  **context** (*behave.runner.Context**,* *optional*) – behave context, defaults to None
* **Returns:**
  context.nm_stopped flag
* **Rtype reset:**
  bool

### nmci.nmutil.context_set_nm_restarted(context=None, reset=False)

Set context.nm_restarted, which indicates that NetworkManager
service was restarted during the test.

Note that this parameter is currently not used anywhere,
but it might be useful for detecting whether a PID change
was expected or not (crash).

* **Parameters:**
  * **context** (*behave.runner.Context**,* *optional*) – behave context, defaults to None
  * **reset** (*bool**,* *optional*) – reset the context.nm_restarted flag, defaults to False

### nmci.nmutil.context_set_nm_stopped(context=None, reset=False)

Set context.nm_stopped, which indicates that NetworkManager
service was stopped during the test.

* **Parameters:**
  * **context** (*behave.runner.Context**,* *optional*) – behave context, defaults to None
  * **reset** (*bool**,* *optional*) – reset the context.nm_stopped flag, defaults to False

### nmci.nmutil.dbus_get_ip_config(dbus_path, addr_family=None)

Retrieves all IP configuration of a given connection setting from dbus.

* **Parameters:**
  * **dbus_path** (*str*) – path to the connection setting
  * **addr_family** (*str**,* *optional*) – address family, defaults to None
* **Raises:**
  * **Exception** – address family not specified
  * **Exception** – address family not detected
* **Returns:**
  all IP configuration of the specific connection setting from dbus
* **Return type:**
  Glib.Variant

### nmci.nmutil.dbus_get_settings(settings_obj_path)

Retrieves all settings of a given connection setting from dbus.

* **Parameters:**
  **settings_obj_path** (*str*) – path to the connection setting
* **Returns:**
  all settings of the specific connection setting from dbus
* **Return type:**
  Glib.Variant

### nmci.nmutil.dbus_props_for_ac(ac_obj_path, interface_name='org.freedesktop.NetworkManager.Connection.Active')

Retrieve all properties for a given active connection from dbus.

* **Parameters:**
  * **ac_obj_path** (*str*) – path to the active connection
  * **interface_name** (*str**,* *optional*) – name of the bus interface,
    defaults to “org.freedesktop.NetworkManager.Connection.Active”
* **Returns:**
  all properties of the connection from dbus
* **Return type:**
  Glib.Variant

### nmci.nmutil.dbus_props_for_dev(dev_obj_path, interface_name='org.freedesktop.NetworkManager.Device')

Retrieve all properties for a given device from dbus.

* **Parameters:**
  * **dev_obj_path** (*str*) – device path
  * **interface_name** (*str**,* *optional*) – name of the bus interface,
    defaults to “org.freedesktop.NetworkManager.Device”
* **Returns:**
  all properties of the device in dbus
* **Return type:**
  Glib.Variant

### nmci.nmutil.dbus_props_for_setting(settings_obj_path, interface_name='org.freedesktop.NetworkManager.Settings.Connection')

Retrieves all properties of a given connection setting from dbus.

* **Parameters:**
  * **settings_obj_path** (*str*) – path to the connection setting
  * **interface_name** (*str**,* *optional*) – name of the bus interface,
    defaults to “org.freedesktop.NetworkManager.Settings.Connection”
* **Returns:**
  all properties of the specific connection setting from dbus
* **Return type:**
  Glib.Variant

### nmci.nmutil.device_status(\*, name=None, device_type=None, get_ipaddrs=False)

Call `nmcli device status` to get a list of profiles. It augments
the result with directly fetched data from D-Bus (the fetched data
is thus not in sync with the data fetched with the nmcli call).

An alternative might be to use NMClient, which works hard to give
a consistent result from one moment (race-free). That is not done
here, but it also would be a different functionality.

* **Parameters:**
  * **name** (*str**,* *optional*) – only show devices with this name, defaults to None
  * **device_type** (*str**,* *optional*) – only show devices with this type, defaults to None
  * **get_ipaddrs** (*bool**,* *optional*) – fetch IP addresses for devices, defaults to False
* **Returns:**
  list of devices
* **Return type:**
  list

### nmci.nmutil.do_NM_service(operation, timeout=None)

Executes a given operation on the NM service.

* **Parameters:**
  * **operation** (*str*) – operation to execute
  * **timeout** (*int**,* *optional*) – Max. wait-time for NM to start, defaults to DEFAULT_TIMEOUT
* **Raises:**
  **AssertionError** – invalid operation

### nmci.nmutil.get_ethernet_devices()

List all ethernet devices that are available in NetworkManager.

* **Returns:**
  list of all available ethernet devices
* **Return type:**
  list[str]

### nmci.nmutil.get_metered()

Retrieves metered property from NetworkManager.

* **Returns:**
  metered property
* **Return type:**
  int

### nmci.nmutil.nm_pid()

Retrieves NM process ID from system.

* **Returns:**
  process id of NetworkManager
* **Return type:**
  int

### nmci.nmutil.nm_size_kb()

Get the memory size of NetworkManager process in KB.

* **Returns:**
  memory size of NetworkManager process in KB
* **Return type:**
  int

### nmci.nmutil.reboot_NM_service(timeout=None)

Reboots the NM service.

* **Parameters:**
  **timeout** (*int**,* *optional*) – Max. wait-time for NM to start, defaults to DEFAULT_TIMEOUT
* **Returns:**
  True, if NM rebooted successfully
* **Return type:**
  bool

### nmci.nmutil.reload_NM_connections()

Wrapper around `nmcli con reload`.

### nmci.nmutil.reload_NM_service(synchronous=False)

Reloads the running NM service.

* **Parameters:**
  **synchronous** (*bool**,* *optional*) – If True, method will wait for NM to finish reloading, defaults to False

### nmci.nmutil.restart_NM_service(reset=True, timeout=None)

Restarts the running NM service, or resets NM from failed state if reset=True is passed.

* **Parameters:**
  * **reset** (*bool**,* *optional*) – If True, NM will be restarted from failed state, defaults to True
  * **timeout** (*int**,* *optional*) – Maximum wait time for restart to happen, defaults to 15
* **Returns:**
  True, if NM restarted successfully
* **Return type:**
  bool

### nmci.nmutil.start_NM_service(pid_wait=True, reset=True, timeout=None)

Starts the NM service.

* **Parameters:**
  * **pid_wait** (*bool**,* *optional*) – If True, method will wait for NM to finish starting, defaults to True
  * **reset** (*bool**,* *optional*) – If True, NM will be started from failed state, defaults to True
  * **timeout** (*int**,* *optional*) – Max. wait-time for NM to start, defaults to DEFAULT_TIMEOUT
* **Returns:**
  True, if NM started successfully
* **Return type:**
  bool

### nmci.nmutil.stop_NM_service(timeout=60)

Stops the NM service.

* **Parameters:**
  **timeout** (*int**,* *optional*) – timeout for process to finish, defaults to 60
* **Returns:**
  True, if NM stopped successfully
* **Return type:**
  bool

### nmci.nmutil.wait_for_nm_bus(timeout=10, do_assert=True)

Waits for NetworkManager bus to start.

* **Parameters:**
  * **timeout** (*int**,* *optional*) – maximum wait time, defaults to DEFAULT_TIMEOUT
  * **do_assert** (*bool**,* *optional*) – if True, method will raise an exception if NM bus is not running, defaults to True
* **Raises:**
  [**nmci.util.ExpectedException**](#nmci.util.ExpectedException) – NetworkManager bus is not running in “timeout” seconds
* **Returns:**
  True, if NM bus is running
* **Return type:**
  bool

### nmci.nmutil.wait_for_nm_pid(timeout=10, old_pid=0, do_assert=True)

Waits for NetworkManager process to start and return its PID.

* **Parameters:**
  * **timeout** (*int**,* *optional*) – maximum wait time, defaults to DEFAULT_TIMEOUT
  * **old_pid** (*int**,* *optional*) – old PID of NetworkManager process, defaults to 0
  * **do_assert** (*bool**,* *optional*) – if True, method will raise an exception if NM is not running, defaults to True
* **Raises:**
  * [**nmci.util.ExpectedException**](#nmci.util.ExpectedException) – NetworkManager is still running with old PID
  * [**nmci.util.ExpectedException**](#nmci.util.ExpectedException) – NetworkManager is not running in “timeout” seconds
* **Returns:**
  PID of NetworkManager process
* **Return type:**
  int

# pexpect

Pexpect helper class for spawning processes and services.

### nmci.pexpect.pexpect_service(command, args=[], timeout=30, maxread=2000, logfile=None, cwd=None, env=None, encoding='utf-8', codec_errors='strict', shell=False, label=None, check=False, cleanup_priority=40)

Spawn a service and return the pexpect object. The service is killed at the end of the scenario.
If the service is still running, it is killed with SIGTERM first, then with SIGKILL.

* **Parameters:**
  * **command** (*str*) – command to execute
  * **args** (*list**,* *optional*) – arguments to the command, defaults to []
  * **timeout** (*int**,* *optional*) – timeout in seconds, defaults to 30
  * **maxread** (*int**,* *optional*) – max bytes to read, defaults to 2000
  * **logfile** (*file**,* *optional*) – logfile to use, defaults to None
  * **cwd** (*str**,* *optional*) – current working directory, defaults to None
  * **env** (*dict**,* *optional*) – environment variables, defaults to None
  * **encoding** (*str**,* *optional*) – encoding to use, defaults to “utf-8”
  * **codec_errors** (*str**,* *optional*) – codec errors to use, defaults to “strict”
  * **shell** (*bool**,* *optional*) – use shell, defaults to False
  * **label** (*str**,* *optional*) – label for the service, defaults to None
  * **check** (*bool**,* *optional*) – check the return code, defaults to False
  * **cleanup_priority** (*int**,* *optional*) – priority for the cleanup, defaults to nmci.Cleanup.PRIORITY_PEXPECT_SERVICE
* **Returns:**
  pexpect object
* **Return type:**
  pexpect

### nmci.pexpect.pexpect_service_find_all(label=None)

Find all pexpect services with a given label.

* **Parameters:**
  **label** (*str**,* *optional*) – label to search for, defaults to None
* **Returns:**
  list of pexpect services
* **Return type:**
  list

### nmci.pexpect.pexpect_spawn(command, args=[], timeout=30, maxread=2000, logfile=None, cwd=None, env=None, encoding='utf-8', codec_errors='strict', shell=False, label=None, check=False)

Spawn a process and return the pexpect object. The process is killed at the end of the step.
If the process is still running, it is killed with SIGTERM first, then with SIGKILL.

* **Parameters:**
  * **command** (*str*) – command to execute
  * **args** (*list**,* *optional*) – arguments to the command, defaults to []
  * **timeout** (*int**,* *optional*) – timeout in seconds, defaults to 30
  * **maxread** (*int**,* *optional*) – max bytes to read, defaults to 2000
  * **logfile** (*file**,* *optional*) – logfile to use, defaults to None
  * **cwd** (*str**,* *optional*) – current working directory, defaults to None
  * **env** (*dict**,* *optional*) – environment variables, defaults to None
  * **encoding** (*str**,* *optional*) – encoding to use, defaults to “utf-8”
  * **codec_errors** (*str**,* *optional*) – codec errors to use, defaults to “strict”
  * **shell** (*bool**,* *optional*) – use shell, defaults to False
  * **label** (*str**,* *optional*) – label for the process, defaults to None
  * **check** (*bool**,* *optional*) – check the return code, defaults to False
* **Returns:**
  pexpect object
* **Return type:**
  pexpect

### nmci.pexpect.process_pexpect_spawn()

Kill all pexpect processes spawned by pexpect_spawn().

* **Raises:**
  **Exception** – if some process failed

# prepare

### nmci.prepare.setup_libreswan(context, mode, dh_group, phase1_al='aes', phase2_al=None)

Setup Libreswan for a given mode and DH group.

* **Parameters:**
  * **context** (*behave.runner.Context*) – behave context
  * **mode** (*str*) – mode of the connection
  * **dh_group** (*str*) – DH group
  * **phase1_al** (*str**,* *optional*) – phase1 algorithm, defaults to “aes”
  * **phase2_al** (*str**,* *optional*) – phase2 algorithm, defaults to None

### nmci.prepare.teardown_libreswan(context)

Teardown Libreswan.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.setup_openvpn(context, tags)

Setup OpenVPN server and client for a given mode and DH group.

* **Parameters:**
  * **context** (*behave.runner.Context*) – behave context
  * **tags** (*list*) – list of tags
* **Returns:**
  OpenVPN server process
* **Return type:**
  pexpect.spawn

### nmci.prepare.setup_strongswan(context)

Setup Strongswan.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.teardown_strongswan(context)

Teardown Strongswan

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.setup_racoon(context, mode, dh_group, phase1_al='aes', phase2_al=None)

Setup Racoon for a given mode and DH group.

* **Parameters:**
  * **context** (*behave.runner.Context*) – behave context
  * **mode** (*str*) – mode of the connection
  * **dh_group** (*str*) – DH group
  * **phase1_al** (*str**,* *optional*) – phase1 algorithm, defaults to “aes”
  * **phase2_al** (*str**,* *optional*) – phase2 algorithm, defaults to None

### nmci.prepare.teardown_racoon(context)

Teardown Racoon.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.setup_hostapd(context)

Setup hostapd.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.teardown_hostapd(context)

Teardown hostapd.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.setup_pkcs11(context)

Setup SoftHSM2 token, key and cert for 802.1x testing.
Don’t touch token, key or cert if they’re already present in order
to avoid SoftHSM errors. No teardown for this reason, too.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.wifi_rescan(context)

Rescan for wireless networks.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

### nmci.prepare.setup_hostapd_wireless(context, args=None)

Setup hostapd for wireless testing.

* **Parameters:**
  * **context** (*behave.runner.Context*) – behave context
  * **args** (*list**,* *optional*) – additional arguments for hostapd_wireless.sh, defaults to None

### nmci.prepare.teardown_hostapd_wireless(context)

Teardown hostapd for wireless testing.

* **Parameters:**
  **context** (*behave.runner.Context*) – behave context

# process

Helper class to run commands and check their output.

### nmci.process.Popen(argv, \*, shell=False, cwd=None, env=None, env_extra=None, stdout=-1, stderr=-1, namespace=None)

Run a command and return a PopenCollect object. The PopenCollect object
can be used to read stdout and stderr and to wait for the process to
finish.

* **Parameters:**
  * **argv** (*str* *or* *list*) – command to run
  * **shell** (*bool**,* *optional*) – run command in shell, defaults to False
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **stdout** (*file**,* *optional*) – stdout for the command, defaults to subprocess.PIPE
  * **stderr** (*file**,* *optional*) – stderr for the command, defaults to subprocess.PIPE
  * **namespace** (*str**,* *optional*) – namespace for the command, defaults to None
* **Returns:**
  PopenCollect object
* **Return type:**
  [PopenCollect](#nmci.process.PopenCollect)

### *class* nmci.process.PopenCollect(proc, argv=None, argv_real=None, shell=None)

Bases: `object`

Wrapper around `subprocess.Popen` that collects stdout and stderr.

#### read_and_poll()

Read stdout and stderr and poll for returncode.

* **Returns:**
  returncode or None if process is still running
* **Return type:**
  int or None

#### read_and_wait(timeout=None)

Read stdout and stderr and wait for returncode.

* **Parameters:**
  **timeout** (*float*) – timeout in seconds
* **Returns:**
  returncode or None if process is still running
* **Return type:**
  int or None

#### terminate_and_wait(timeout_before_kill=5)

Terminate process and wait for returncode.

* **Parameters:**
  **timeout_before_kill** (*float*) – timeout in seconds before sending SIGKILL
* **Returns:**
  returncode or None if process is still running
* **Return type:**
  int or None

### *class* nmci.process.RunResult(returncode, stdout, stderr)

Bases: `tuple`

Create new instance of RunResult(returncode, stdout, stderr)

#### returncode

Alias for field number 0

#### stderr

Alias for field number 2

#### stdout

Alias for field number 1

### *class* nmci.process.With(cmd)

Bases: `object`

Helper class to allow WithPrefix and WithNamespace to be used
interchangeably with strings.

#### get_argv()

#### get_shell()

### *class* nmci.process.WithNamespace(namespace, cmd)

Bases: [`WithPrefix`](#nmci.process.WithPrefix)

Helper class to allow WithNamespace to be used interchangeably with strings.

### *class* nmci.process.WithPrefix(prefix, cmd)

Bases: [`With`](#nmci.process.With)

Helper class to allow WithPrefix to be used interchangeably with strings.

#### get_argv()

### *class* nmci.process.WithShell(cmd)

Bases: [`With`](#nmci.process.With)

Helper class to allow WithShell to be used interchangeably with strings.

#### get_shell()

### nmci.process.nmcli(argv, \*, as_bytes=False, timeout=60, cwd=None, env=None, env_extra=None, ignore_returncode=False, ignore_stderr=False, ignore_stdout_error=False, embed_combine_tag=<object object>)

Run `nmcli` command and check its output. If the command fails, or prints
anything to stderr, an exception is raised. Otherwise, a RunResult
object is returned.

* **Parameters:**
  * **argv** (*str* *or* *list*) – nmcli arguments added to the command’s execution
  * **as_bytes** (*bool**,* *optional*) – return stdout and stderr as bytes, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 60
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to False
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to False
  * **ignore_stdout_error** (*bool**,* *optional*) – ignore stdout error of the command, defaults to False
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
* **Returns:**
  RunResult object
* **Return type:**
  [RunResult](#nmci.process.RunResult)

### nmci.process.nmcli_force(argv, \*, as_bytes=False, timeout=60, cwd=None, env=None, env_extra=None, ignore_returncode=True, ignore_stderr=True, embed_combine_tag=<object object>)

Run `nmcli` command and check its output. If the command fails, or prints
anything to stderr, an exception is raised. Otherwise, a RunResult object is returned.
This function is used for commands that are expected to fail, but we want to check
the output anyway.

* **Parameters:**
  * **argv** (*str* *or* *list*) – nmcli arguments added to the command’s execution
  * **as_bytes** (*bool**,* *optional*) – return stdout and stderr as bytes, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 60
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to True
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to True
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
* **Returns:**
  RunResult object
* **Return type:**
  [RunResult](#nmci.process.RunResult)

### nmci.process.raise_results(argv, header, result)

Helper function to raise an exception containing output of the command.

* **Parameters:**
  * **argv** (*str* *or* *list*) – command to run
  * **header** (*str*) – header for the exception
  * **result** ([*RunResult*](#nmci.process.RunResult)) – result of the command
* **Raises:**
  **Exception** – exception containing output of the command

### nmci.process.run(argv, \*, shell=False, as_bytes=False, timeout=5, cwd=None, env=None, env_extra=None, ignore_returncode=True, ignore_stderr=False, stdout=-1, stderr=-1, embed_combine_tag=<object object>, namespace=None)

Run a command and check its output. If the command fails, or
prints anything to stderr, an exception is raised. Otherwise, a RunResult
object is returned.

* **Parameters:**
  * **argv** (*str* *or* *list*) – command to run
  * **shell** (*bool**,* *optional*) – run command in shell, defaults to False
  * **as_bytes** (*bool**,* *optional*) – return stdout and stderr as bytes, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 5
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to True
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to False
  * **stdout** (*file**,* *optional*) – stdout for the command, defaults to subprocess.PIPE
  * **stderr** (*file**,* *optional*) – stderr for the command, defaults to subprocess.PIPE
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
  * **namespace** (*str**,* *optional*) – namespace for the command, defaults to None
* **Returns:**
  RunResult object
* **Return type:**
  [RunResult](#nmci.process.RunResult)

### nmci.process.run_code(argv, \*, shell=False, as_bytes=False, timeout=5, cwd=None, env=None, env_extra=None, ignore_returncode=True, ignore_stderr=False, embed_combine_tag=<object object>, namespace=None)

Run a command and return its returncode. If the command fails, or prints
anything to stderr, an exception is raised.

* **Parameters:**
  * **argv** (*str* *or* *list*) – command to run
  * **shell** (*bool**,* *optional*) – run command in shell, defaults to False
  * **as_bytes** (*bool**,* *optional*) – return stdout and stderr as bytes, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 5
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to True
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to False
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
  * **namespace** (*str**,* *optional*) – namespace for the command, defaults to None
* **Returns:**
  returncode of the command
* **Return type:**
  int

### nmci.process.run_search_stdout(argv, pattern, \*, shell=False, timeout=5, cwd=None, env=None, env_extra=None, ignore_returncode=False, ignore_stderr=False, stderr=-1, pattern_flags=<object object>, embed_combine_tag=<object object>, namespace=None)

Run a command and search its stdout for a pattern. If the command fails, or
prints anything to stderr, an exception is raised. Otherwise, a re.Match
object is returned.

* **Parameters:**
  * **argv** (*str* *or* *list*) – command to run
  * **pattern** (*str* *or* *bytes* *or* *re.Pattern*) – pattern to search for
  * **shell** (*bool**,* *optional*) – run command in shell, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 5
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to False
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to False
  * **stderr** (*file**,* *optional*) – stderr for the command, defaults to subprocess.PIPE
  * **pattern_flags** (*int**,* *optional*) – pattern_flags for the command, defaults to re.DOTALL | re.MULTILINE
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
  * **namespace** (*str**,* *optional*) – namespace for the command, defaults to None
* **Returns:**
  re.Match object
* **Return type:**
  re.Match

### nmci.process.run_stdout(argv, \*, shell=False, as_bytes=False, timeout=5, cwd=None, env=None, env_extra=None, ignore_returncode=False, ignore_stderr=False, stderr=-1, embed_combine_tag=<object object>, namespace=None)

Run a command and return its stdout. If the command fails, or prints
anything to stderr, an exception is raised.

* **Parameters:**
  * **argv** (*str* *or* *list*) – command to run
  * **shell** (*bool**,* *optional*) – run command in shell, defaults to False
  * **as_bytes** (*bool**,* *optional*) – return stdout as bytes, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 5
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to False
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to False
  * **stderr** (*file**,* *optional*) – stderr for the command, defaults to subprocess.PIPE
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
  * **namespace** (*str**,* *optional*) – namespace for the command, defaults to None
* **Returns:**
  stdout of the command
* **Return type:**
  str or bytes

### nmci.process.systemctl(argv, \*, as_bytes=False, timeout=60, cwd=None, env=None, env_extra=None, ignore_returncode=True, ignore_stderr=True, embed_combine_tag=<object object>)

Run `systemctl` command and check its output. If the command fails, or prints
anything to stderr, an exception is raised. Otherwise, a RunResult object is returned.

* **Parameters:**
  * **argv** (*str* *or* *list*) – systemctl arguments added to the command’s execution
  * **as_bytes** (*bool**,* *optional*) – return stdout and stderr as bytes, defaults to False
  * **timeout** (*int**,* *optional*) – timeout for the command, defaults to 60
  * **cwd** (*str**,* *optional*) – cwd for the command, None replaced by nmci.util.BASE_DIR, defaults to None
  * **env** (*dict**,* *optional*) – env for the command, defaults to None
  * **env_extra** (*dict**,* *optional*) – env_extra for the command, defaults to None
  * **ignore_returncode** (*bool**,* *optional*) – ignore returncode of the command, defaults to True
  * **ignore_stderr** (*bool**,* *optional*) – ignore stderr of the command, defaults to True
  * **embed_combine_tag** (*str**,* *optional*) – embed_combine_tag for the command, defaults to TRACE_COMBINE_TAG
* **Returns:**
  RunResult object
* **Return type:**
  [RunResult](#nmci.process.RunResult)

# sdresolved

This class provides access to the sd-resolved D-Bus API. It is a singleton
and can be accessed via the `nmci.sdresolved` module.

### nmci.sdresolved.get_link(ifindex)

Resolve the ifindex to a D-Bus path.

* **Parameters:**
  **ifindex** (*int* *or* *str*) – the ifindex to resolve
* **Returns:**
  the resolved D-Bus path
* **Return type:**
  str

### nmci.sdresolved.link_get_all(ifindex)

Resolve the ifindex to a D-Bus path,
and retrieve all DNS addresses, domains, and default routes
for the given ifindex.

* **Parameters:**
  **ifindex** (*int* *or* *str*) – the ifindex to resolve
* **Returns:**
  dict of DNS addresses, domains, and default routes
* **Return type:**
  dict

### nmci.sdresolved.link_get_default_route(ifindex)

Resolve the ifindex to a D-Bus path,
and retrieve the default routes for the given ifindex.

* **Parameters:**
  **ifindex** (*int* *or* *str*) – the ifindex to resolve
* **Raises:**
  GLib.Error if the DefaultRoute property is not available
* **Returns:**
  list of default routes
* **Return type:**
  list of str

### nmci.sdresolved.link_get_dns(ifindex)

Resolve the ifindex to a D-Bus path,
and retrieve all DNS addresses for the given ifindex.

* **Parameters:**
  **ifindex** (*int* *or* *str*) – the ifindex to resolve
* **Raises:**
  GLib.Error if the DNS property is not available
* **Returns:**
  list of DNS addresses
* **Return type:**
  list of str

### nmci.sdresolved.link_get_domains(ifindex)

Resolve the ifindex to a D-Bus path,
and retrieve all domains.

* **Parameters:**
  **ifindex** (*int* *or* *str*) – the ifindex to resolve
* **Returns:**
  list of Domains
* **Return type:**
  list of (str, str)

# util

Utility functions. This is a singleton class. Use `nmci.util` to access
the singleton instance.

### *exception* nmci.util.ExpectedException

Bases: `Exception`

Expected exception. We don’t want to just catch blindly all “Exception” types
but rather only those exceptions where an API is known that it might fail and fails
with a particular exception type.

Usually, we would thus add various Exception classes that carry specific information
about the failure reason. However, that is sometimes just cumbersome.

This exception type fills this purpose. It’s not very specific but it’s specific
enough that we can catch it for functions that are known to have certain failures
– while not needing to swallow all exceptions.

### *class* nmci.util.FileGetContentResult(data, full_file)

Bases: `tuple`

Create new instance of FileGetContentResult(data, full_file)

#### data

Alias for field number 0

#### full_file

Alias for field number 1

### nmci.util.base_dir(\*args)

Base directory of NM-ci.

* **Parameters:**
  **args** (*list*) – additional path components
* **Returns:**
  base directory of NM-ci with additional path
* **Return type:**
  str

### nmci.util.binary_to_str(b, binary=None)

Convert bytes to string. This is the same as bytes_to_str() but it
also supports returning binary (if the caller accepts it).

* **Parameters:**
  * **b** (*bytes*) – bytes
  * **binary** (*bool**,* *optional*) – whether to return binary, defaults to None
    - None (return string)
    - False (return string)
    - True (return binary)
* **Returns:**
  string
* **Return type:**
  str

### nmci.util.bytes_to_str(s, errors='strict')

Convert bytes to string.

* **Parameters:**
  * **s** (*bytes*) – bytes
  * **errors** (*str**,* *optional*) – errors, defaults to “strict”
* **Returns:**
  string
* **Return type:**
  str

### nmci.util.compare_strv_list(expected, strv, match_mode='auto', ignore_extra_strv=True, ignore_order=True)

Compare the `strv` list of strings with `expected`. If the list differs,
a ValueError gets raised. Otherwise it return True.

* **Parameters:**
  * **expected** (*list* *or* *str*) – the list of expected items. It can be a plain string,
    or a regex string (see `match_mode`).
  * **strv** (*list*) – the string list that we check.
  * **match_mode** (*str*) – how the elements in `expected` are compared against `strv`
    - “plain”: direct string comparison. The default is “plain” if no prefix is given
    - “regex”: regular expression using re.search(e, s)
    - “auto”: each element can encode whether to be an optional match (starting
    with ‘?’), and whether to use regex/plain mode (‘/’ vs. ‘=’).
  * **ignore_extra_strv** (*bool*) – if True, extra non-matched elementes in strv are silently accepted
  * **ignore_order** (*bool*) – if True, the order is not checked. Otherwise, the
    elements in `expected` must match in the right order.
    For example, with `match_mode='regex'`, `expected=['a', '.']`,
    `strv=['b', 'a']`, this matches when ignoring the order,
    but fails to match otherwise.
    An element in `expected` only can match exactly once.

### nmci.util.consume_list(lst)

Consume list. This is a generator that consumes a list (removing all elements,
from the beginning) and returns an iterator for the elements.

* **Parameters:**
  **lst** (*list*) – list
* **Returns:**
  iterator for the elements
* **Return type:**
  iterator

### nmci.util.directory_remove(dir_name, recursive=False, do_assert=False)

Remove directory, ignore if it does not exist.

* **Parameters:**
  * **dir_name** (*str*) – directory name
  * **recursive** (*bool**,* *optional*) – remove recursively, defaults to False
  * **do_assert** (*bool**,* *optional*) – raise exception if directory does not exist, defaults to False

### nmci.util.dump_memory_stats()

Dump memory stats. This is useful for debugging purposes. It dumps
the memory consumption of NetworkManager and the memory consumption of
the NetworkManager process itself (if it’s running under valgrind).

* **Returns:**
  a string with memory stats
* **Return type:**
  str

### nmci.util.dump_status(when)

Dump status of the system to the log. This is useful for debugging
purposes. It dumps the status of NetworkManager, systemd-resolved,
the vethsetup network namespace and the other named network namespaces. It
also dumps the routing tables and the firewall rules. It’s a lot of
information, so it’s only dumped when the test fails. It can be
enabled for all tests by setting the `NMCI_DUMP_STATUS` environment
variable to “1”.

* **Parameters:**
  **when** (*str*) – when to dump the status

### nmci.util.fd_get_content(file, max_size=None, warn_max_size=True)

Get content of file. This is a low-level function that reads the file and
returns the content as bytes. It also returns a flag that indicates whether
the file was read completely or whether the maximum size was reached.

* **Parameters:**
  * **file** (*file*) – file
  * **max_size** (*int**,* *optional*) – maximum size of file, defaults to None
  * **warn_max_size** (*bool**,* *optional*) – warn if maximum size is reached, defaults to True
* **Returns:**
  content of file
* **Return type:**
  [FileGetContentResult](#nmci.util.FileGetContentResult)

### nmci.util.file_get_content(file_name, encoding='utf-8', errors='strict', max_size=None, warn_max_size=True)

Get content of file.

* **Parameters:**
  * **file_name** (*str*) – file name
  * **encoding** (*str**,* *optional*) – encoding, defaults to “utf-8”
  * **errors** (*str**,* *optional*) – errors, defaults to “strict”
  * **max_size** (*int**,* *optional*) – maximum size of file, defaults to None
  * **warn_max_size** (*bool**,* *optional*) – warn if maximum size is reached, defaults to True
* **Returns:**
  content of file
* **Return type:**
  [FileGetContentResult](#nmci.util.FileGetContentResult)

### nmci.util.file_get_content_simple(file_name, as_bytes=False)

Get content of file. This is a simplified version of file_get_content() that
returns the content as string or bytes (depending on `as_bytes`) and does not
return the `full_file` flag. It also does not support `max_size` and
`warn_max_size`.

* **Parameters:**
  * **file_name** (*str*) – file name
  * **as_bytes** (*bool**,* *optional*) – return bytes instead of str, defaults to False
* **Returns:**
  content of file
* **Return type:**
  str or bytes

### nmci.util.file_remove(file_name, do_assert=False)

Remove file, ignore if it does not exist.

* **Parameters:**
  * **file_name** (*str*) – file name
  * **do_assert** (*bool**,* *optional*) – raise exception if file does not exist, defaults to False

### nmci.util.file_set_content(file_name, data='')

Set content of file.

* **Parameters:**
  * **file_name** (*str*) – file name
  * **data** (*str* *or* *bytes* *or* *list**[**str**] or* *list**[**bytes**]**,* *optional*) – data to write, accepts string, bytes or list of lines, defaults to “”

### nmci.util.gvariant_to_dict(variant)

Convert GVariant to dict.

* **Parameters:**
  **variant** (*GLib.Variant*) – GVariant
* **Returns:**
  dict
* **Return type:**
  dict

### nmci.util.gvariant_type(s)

Convert a string to a GVariantType.

* **Parameters:**
  **s** (*str* *or* *GLib.VariantType*) – the string to convert
* **Returns:**
  the GVariantType
* **Return type:**
  GLib.VariantType

### nmci.util.is_verbose()

Whether NM-ci runs in verbose mode.

* **Returns:**
  whether NM-ci runs in verbose mode
* **Return type:**
  bool

### nmci.util.nmci_random_seed()

Return the global random seed. The seed is read from the environment.

* **Returns:**
  the global random seed.
* **Return type:**
  int

### nmci.util.random_bool(seed)

Return a random boolean value.

* **Parameters:**
  **seed** (*str*) – the seed to use for the random.Random instance.
* **Returns:**
  a random boolean value.
* **Return type:**
  bool

### nmci.util.random_float(seed, minval=0.0, maxval=1.0)

Return a random float in the range [minval, maxval).

* **Parameters:**
  * **seed** (*str*) – the seed to use for the random.Random instance.
  * **minval** (*float*) – the minimum value of the random float.
  * **maxval** (*float*) – the maximum value of the random float.
* **Returns:**
  a random float in the range [minval, maxval).
* **Return type:**
  float

### nmci.util.random_generator(seed)

Return a random.Random instance. The instance is seeded with the
global seed and the given seed. The global seed is read from the
environment variable NMCI_RANDOM_SEED. If the variable is not set, a
random seed is generated and stored in a file in the .tmp directory.

* **Parameters:**
  **seed** (*str*) – the seed to use for the random.Random instance.
* **Returns:**
  a random.Random instance.
* **Return type:**
  random.Random

### nmci.util.random_int(seed, minval=0, maxval=4294967295)

Return a random integer in the range [minval, maxval].

* **Parameters:**
  * **seed** (*str*) – the seed to use for the random.Random instance.
  * **minval** (*int*) – the minimum value of the random integer.
  * **maxval** (*int*) – the maximum value of the random integer.
* **Returns:**
  a random integer in the range [minval, maxval].
* **Return type:**
  int

### nmci.util.random_iter_int(seed, minval=0, maxval=4294967295)

Return an iterator that yields random integers in the range [minval, maxval].

* **Parameters:**
  * **seed** (*str*) – the seed to use for the random.Random instance.
  * **minval** (*int*) – the minimum value of the random integer.
  * **maxval** (*int*) – the maximum value of the random integer.
* **Returns:**
  an iterator that yields random integers in the range [minval, maxval].
* **Return type:**
  Iterator[int]

### nmci.util.set_verbose(value=True)

Set verbose mode.

* **Parameters:**
  **value** (*bool**,* *optional*) – whether to set verbose mode, defaults to True

### nmci.util.start_timeout(timeout=None, name=None)

Start timeout. This is useful for timeouts that are used in a `with`
statement. It returns a timeout object that can be used to check whether
the timeout has expired. It also raises an exception if the timeout has expired
when the with statement ends.

* **Parameters:**
  * **timeout** (*\_Timeout* *or* *str* *or* *number**,* *optional*) – timeout, defaults to None
    - \_Timeout object (use remaining time)
    - None (infinity)
    - str or number (timeout in seconds)
  * **name** (*str**,* *optional*) – name of timeout, defaults to None
* **Returns:**
  timeout object
* **Return type:**
  \_Timeout

### nmci.util.str_matches(string, pattern)

Matches “string” with “pattern”.

* **Parameters:**
  * **string** (*str*) – string
  * **pattern** (*str* *or* *re.Pattern* *or* *list*) – pattern
    - a plain string (compared with ==)
    - a re.Pattern instance (compared with re.Pattern.search())
    or re._pattern_type on python-=3.6
    - an interable/list of above.
* **Returns:**
  whether string matches pattern
* **Return type:**
  bool

### nmci.util.str_to_bytes(s)

Convert string to bytes.

* **Parameters:**
  **s** (*str*) – string
* **Returns:**
  bytes
* **Return type:**
  bytes

### nmci.util.str_whitespace_join(args)

Join a list of strings at whitespace, but support backslash escaping
to prevent splitting.

This basically allows to express a string list in one string,
separated by space. It only supports a minimum of extra escaping,
to allow a space not be treated as separator. Most backslash
is treated verbatim.

This allows to write expressions, that themselves might be backslash
escaped, without requiring additional backslash escaping.
For example, regexes: `["^.$", "^ \["]` gives the string `"^.$ ^\ \["`

* **Parameters:**
  **args** (*list*) – the list of strings to join
  The empty list joins to None and not to “”.
  That’s because [“”] already joins to “”, but we want a unique
  result for every join (so that it can be reverted). That’s why we
  don’t return a string for the empty list.
* **Returns:**
  the joined string
* **Return type:**
  str

### nmci.util.str_whitespace_split(text, remove_empty=True)

Split a string at whitespace, but support backslash escaping
to prevent splitting.

This basically allows to express a string list in one string,
separated by space. It only supports a minimum of extra escaping,
to allow a space not be treated as separator. Most backslash
is treated verbatim.

This allows to write expressions, that themselves might be backslash
escaped, without requiring additional backslash escaping.
For example, regexes: `"^.$ ^\ \["` gives the two regexes `["^.$", "^ \["]`

This will:
- None gives the empty list [] (so that every input strlist can be joined and split again).
- take double backslash `"\\"` as a single backslash `"\"`
- take escaped space `"\ "` as a single space
- take a single whitespace to split the string (the whitespace is removed).
- any other escaped backslash is taken literally.

* **Parameters:**
  * **text** (*str*) – the string to split
  * **remove_empty** (*bool*) – if True, empty tokens are dropped from the result.
    With `remove_empty=False`, `split(join(strlist))` gives `strlist`.
* **Returns:**
  the list of strings
* **Return type:**
  list

### nmci.util.tmp_dir(\*args, create_base_dir=True)

Temporary directory of NM-ci.

* **Parameters:**
  * **args** (*list*) – additional path components
  * **create_base_dir** (*bool*) – whether NM-ci base directory should be created
* **Returns:**
  temporary directory of NM-ci with additional path
* **Return type:**
  str

### nmci.util.update_udevadm()

Update udevadm rules and wait for udev to settle. This is useful when
udev rules are changed and the changes should be applied immediately.

* **Raises:**
  [**nmci.util.ExpectedException**](#nmci.util.ExpectedException) – if udevadm failed

### nmci.util.util_dir(\*args)

Get util directory.

* **Parameters:**
  **args** (*list*) – additional path components
* **Returns:**
  util directory
* **Return type:**
  str

### nmci.util.wait_for(callback, timeout=5, poll_sleep_time=0.2, handle_result=None, handle_exception=None, handle_timeout=None, op_name=None)

Waits for up to “timeout” seconds, with a poll-interval of “poll_sleep_time”.

The main mode of operation is simply that the “callback” raises an exception
if the thing that we wait for is not yet reached. In that mode,
- the function retries until timeout or until “callback” does not raise
- on success, the return value of “callback” is returned.
- on timeout, the last_exception is re-raised.

You can also pass “handle_result”, “handle_exception” and “handle_timeout”
callbacks, to modify the behavior.

* **Parameters:**
  * **callback** (*callable*) – the callback to call.
  * **timeout** (*float*) – the timeout in seconds.
  * **poll_sleep_time** (*float*) – the poll sleep time in seconds.
  * **handle_result** (*callable*) – a callback that is called with the result of the callback.
  * **handle_exception** (*callable*) – a callback that is called with the exception raised by the callback.
  * **handle_timeout** (*callable*) – a callback that is called with the last exception raised by the callback.
  * **op_name** (*str*) – the name of the operation.
* **Returns:**
  the result of the callback.
* **Return type:**
  any

# veth

### nmci.veth.check_vethsetup()

Re-run the veth setup while validating its correct execution.

### nmci.veth.manage_device(device, rule_name=None)

Set device mode to ‘managed’.

* **Parameters:**
  * **device** (*str*) – name of the device
  * **rule_name** (*str**,* *optional*) – name of the custom udev rule, defaults to None

### nmci.veth.manage_veths()

Set the mode to ‘managed’ for all veth devices with names accepted by the regex `eth[0-9]*[0-9]?`.

### nmci.veth.reset_hwaddr_nmcli(ifname)

Reset the link-local address of a given interface.

* **Parameters:**
  **ifname** (*str*) – name of the device

### nmci.veth.restore_connections()

Delete all custom devices besides eth/lo/orig, and recreate testeth connection profiles.

### nmci.veth.restore_testeth0()

Restore the testeth0 configuration.

### nmci.veth.teardown_testveth(ns)

Remove the testveth setup in a given namespace.

* **Parameters:**
  **ns** (*str*) – namespace identifier

### nmci.veth.unmanage_veths()

Removes the `88-veths-*` udev rule, which sets the mode to “managed”
for all veth devices with names accepted by the regex `eth[0-9]*[0-9]?`.

### nmci.veth.wait_for_testeth0()

Wait for the testeth0 connection to sucessfully activate from multiple states.

Possible states:
- If it does not exist, restore it.
- If it is not running, activate it.
- If it does not have ipv4 addr/gateway/dns assigned, wait for the assignment.
