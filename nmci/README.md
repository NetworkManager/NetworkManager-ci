# NMCI - NetworkManager-ci Library

Do not edit this file. This is generated by `sphinx-build` from source [`nmci/doc_src/index.rst`](nmci/doc_src/index.rst).

## Adding standard python module (e.g. `nmci.prepare`)

When created, do not forget to import it at the end of [`nmci/__init__.py`](nmci/__init__.py) file, otherwise it will not be imported with `import nmci`.

## Adding new module as class (e.g. `nmci.process`)

If module is written as python class `_ClassMod` in `nmci/classmod.py`, do not forget to


1. Define `_module = _ClassMod()` at the end of file.


2. Define `__getattr__()` to avoid not fully loaded modules within `nmci`.

```python
def __getattr__(attr):
    return getattr(_module, attr)
```


1. Add module to file [`nmci/__init__.py`](nmci/__init__.py):

```python
import nmci.classmod
# this line is important for autocomplete to work correctly
classmod = nmci.classmod._module
sys.modules["nmci.classmod"] = classmod
```

Remember, if you define another classes in `nmci/classmod.py`, they will not be accessible,
unless you set them as attributes of `_ClassMod`.

## Add module to documentation

Add following in [`nmci/doc_src/index.rst`](nmci/doc_src/index.rst):

```markdown
my_new_mod
==========

.. automodule:: nmci.my_new_mod
   :members:
   :undoc-members:
   :show-inheritance:
```

Regenerate the documentation from source:

```bash
sphinx-build -E -a -b markdown nmci/doc_src nmci/doc
```

Results should be in [`nmci/doc/markdown/index.md`](nmci/doc/markdown/index.md).

# API of the nmci modules.

# cext

Context Extenstion object
Remembers the current behave context and implements
basic operations over it.


### nmci.cext.setup(context)
Setup context formatter, commands, and save context.


* **Parameters**

    **context** (*behave.Context*) – behave context object



### nmci.cext.skip(msg='')
Skip scenario and stop executing (raise SkipTestException).


* **Parameters**

    **msg** (*str**, **optional*) – Reason of skip, defaults to “”



* **Raises**

    **nmci.misc.SkipTestException** – Interupts further code execution


# cleanup


### _class_ nmci.cleanup.Cleanup(callback=None, name=None, unique_tag=None, priority=0, also_needs=None)
Bases: `object`

Generic cleanup


* **Parameters**

    
    * **callback** (*callable**, **optional*) – cleanup method to be called, defaults to None


    * **name** (*str**, **optional*) – human readable description, defaults to None


    * **unique_tag** (*object**, **optional*) – comparison key to merge duplicit cleanups, by default, all instances of Cleanup are considered distinct, all instances of descendant classes are considered equal


    * **priority** (*int**, **optional*) – defines order in which the cleanups are executed, defaults to PRIORITY_CALLBACK_DEFAULT


    * **also_needs** (*callable**, **optional*) – dependent cleanups, should be callable returning iterable of Cleanup objects, defaults to None



#### PRIORITY_CALLBACK_DEFAULT(_ = _ )

#### PRIORITY_CONNECTION(_ = 2_ )

#### PRIORITY_FILE(_ = 7_ )

#### PRIORITY_IFACE_DELETE(_ = 3_ )

#### PRIORITY_IFACE_RESET(_ = 3_ )

#### PRIORITY_MPTCP(_ = 3_ )

#### PRIORITY_NAMESPACE(_ = 3_ )

#### PRIORITY_NFT_DEFAULT(_ = 4_ )

#### PRIORITY_NFT_OTHER(_ = 4_ )

#### PRIORITY_NM_SERVICE_RESTART(_ = 20_ )

#### PRIORITY_NM_SERVICE_START(_ = -3_ )

#### PRIORITY_PEXPECT_SERVICE(_ = 4_ )

#### PRIORITY_SYSCTL(_ = 2_ )

#### PRIORITY_TAG(_ = 1_ )

#### PRIORITY_UDEV_RULE(_ = 5_ )

#### PRIORITY_UDEV_UPDATE(_ = 30_ )

#### UNIQ_TAG_DISTINCT(_ = <object object_ )

### _class_ nmci.cleanup.CleanupConnection(con_name, qualifier=None, priority=20)
Bases: `nmci.cleanup._Cleanup.Cleanup`

Cleanup NetworkManager connection


* **Parameters**

    
    * **con_name** (*str*) – name or UUID of the connection to cleanup


    * **qualifier** (*str**, **optional*) – optional qualifier (‘id’ or ‘uuid’), defaults to None


    * **priority** (*int**, **optional*) – cleanup priority, defaults to PRIORITY_CONNECTION



### _class_ nmci.cleanup.CleanupFile(\*files, glob=None, priority=70, name=None, unique_tag=None)
Bases: `nmci.cleanup._Cleanup.Cleanup`

File cleanup, removes file if exists.


* **Parameters**

    
    * **priority** (*int**, **optional*) – cleanup priority, defaults to PRIORITY_FILE


    * **name** (*str**, **optional*) – description of cleanup, defaults to None


    * **glob** (*string** or **iterable of string**, **optional*) – glob expression(s) of filenames



### _class_ nmci.cleanup.CleanupIface(iface, op=None, priority=None)
Bases: `nmci.cleanup._Cleanup.Cleanup`

Cleanup the network interafce


* **Parameters**

    
    * **iface** (*str** or **list of str*) – name of the interface


    * **op** (*str**, **optional*) – operation, one of ‘delete’, ‘ip-delete’ or ‘reset’, defaults to ‘reset’ on eth0…eth10, ‘delete’ otherwise


    * **priority** (*int**, **optional*) – cleanup priority, defaults to PRIORITY_IFACE_DELETE or PRIORITY_IFACE_RESET



### _class_ nmci.cleanup.CleanupMptcpEndpoints()
Bases: `nmci.cleanup._Cleanup.Cleanup`

MPTCP endpoint cleanups


### _class_ nmci.cleanup.CleanupMptcpLimits(namespace=None)
Bases: `nmci.cleanup._Cleanup.Cleanup`

MPTCP limits cleanup


* **Parameters**

    **namespace** (*str**, **optional*) – name of namespace, defaults to None



### _class_ nmci.cleanup.CleanupNMConfig(config_file, config_directory=None, priority=70, schedule_nm_restart=True)
Bases: `nmci.cleanup._Cleanup.CleanupFile`

Cleanup NetworkManager config file and restart.


* **Parameters**

    
    * **config_file** (*str*) – NetworkManager config file name, either full path, or relative path accepted.


    * **config_directory** (*str**, **optional*) – NetworkManager config directory, one of ‘etc’, ‘usr’, ‘run’, defaults to ‘etc’


    * **priority** (*int**, **optional*) – cleanup priority, defaults to PRIORITY_FILE



### _class_ nmci.cleanup.CleanupNMService(operation='restart', timeout=None, priority=None, name=None)
Bases: `nmci.cleanup._Cleanup.Cleanup`

NetworkManager systemd service cleanup. Accepts start, restart, and reload.


* **Parameters**

    
    * **operation** (*str*) – operation on systemd service, one of ‘start’, ‘restart’ or ‘reload’.


    * **priority** (*int**, **optional*) – cleanup priortiy, defaults to None



### _class_ nmci.cleanup.CleanupNamespace(namespace, teardown=True, priority=30)
Bases: `nmci.cleanup._Cleanup.Cleanup`

Generic cleanup


* **Parameters**

    
    * **callback** (*callable**, **optional*) – cleanup method to be called, defaults to None


    * **name** (*str**, **optional*) – human readable description, defaults to None


    * **unique_tag** (*object**, **optional*) – comparison key to merge duplicit cleanups, by default, all instances of Cleanup are considered distinct, all instances of descendant classes are considered equal


    * **priority** (*int**, **optional*) – defines order in which the cleanups are executed, defaults to PRIORITY_CALLBACK_DEFAULT


    * **also_needs** (*callable**, **optional*) – dependent cleanups, should be callable returning iterable of Cleanup objects, defaults to None



### _class_ nmci.cleanup.CleanupNft(namespace=None, priority=None)
Bases: `nmci.cleanup._Cleanup.Cleanup`

NFT rules cleanup


* **Parameters**

    
    * **namespace** (*str**, **optional*) – name of namespace, defaults to None


    * **priority** (*int**, **optional*) – cleanup priority, defaults to None



### _class_ nmci.cleanup.CleanupSysctls(sysctls_pattern, namespace=None)
Bases: `nmci.cleanup._Cleanup.Cleanup`

Sysctl cleanup - reset to original value.


* **Parameters**

    
    * **sysctls_pattern** (*str*) – sysctl pattern to save


    * **namespace** (*str**, **optional*) – name of namespace, defaults to None



### _class_ nmci.cleanup.CleanupUdevRule(rule, priority=50)
Bases: `nmci.cleanup._Cleanup.CleanupFile`

Udev rule file cleanup


* **Parameters**

    
    * **rule** (*str*) – name of file containing udev rule


    * **priority** (*int**, **optional*) – cleanup priortiy, defaults to PRIORITY_UDEV_RULE



### _class_ nmci.cleanup.CleanupUdevUpdate(priority=300)
Bases: `nmci.cleanup._Cleanup.Cleanup`

Udev update cleanup, calls updates and settles udev


* **Parameters**

    **priority** (*int**, **optional*) – cleanup priortiy, defaults to PRIORITY_UDEV_UPDATE



### nmci.cleanup.cleanup_add()
alias of `nmci.cleanup._Cleanup.Cleanup`


### nmci.cleanup.cleanup_add_NM_service()
alias of `nmci.cleanup._Cleanup.CleanupNMService`


### nmci.cleanup.cleanup_add_connection()
alias of `nmci.cleanup._Cleanup.CleanupConnection`


### nmci.cleanup.cleanup_add_iface()
alias of `nmci.cleanup._Cleanup.CleanupIface`


### nmci.cleanup.cleanup_add_ip_mptcp_endpoints()
alias of `nmci.cleanup._Cleanup.CleanupMptcpEndpoints`


### nmci.cleanup.cleanup_add_ip_mptcp_limits()
alias of `nmci.cleanup._Cleanup.CleanupMptcpLimits`


### nmci.cleanup.cleanup_add_namespace()
alias of `nmci.cleanup._Cleanup.CleanupNamespace`


### nmci.cleanup.cleanup_add_nft()
alias of `nmci.cleanup._Cleanup.CleanupNft`


### nmci.cleanup.cleanup_add_sysctls()
alias of `nmci.cleanup._Cleanup.CleanupSysctls`


### nmci.cleanup.cleanup_add_udev_rule()
alias of `nmci.cleanup._Cleanup.CleanupUdevRule`


### nmci.cleanup.cleanup_file()
alias of `nmci.cleanup._Cleanup.CleanupFile`


### nmci.cleanup.cleanup_nm_config()
alias of `nmci.cleanup._Cleanup.CleanupNMConfig`


### nmci.cleanup.process_cleanup()
Exectue the cleanups honoring its order.


* **Returns**

    list of Exceptions that hapenned during cleanups



* **Return type**

    list of Exception


# crash


### nmci.crash.check_dump_package(pkg_name)
Helper function to check if package name is relevant.


* **Parameters**

    **pkg_name** (*ste*) – name of the package



* **Returns**

    True if NetworkManager or ModemManager, False otherwise



* **Return type**

    bool



### nmci.crash.check_crash(context, crashed_step)
Check if crash hapenned (by NM PID change), remember step when crash occured in context.


* **Parameters**

    
    * **context** (*behave.Context*) – behave Context object


    * **crashed_step** (*str*) – Name of the crashed step



### nmci.crash.check_coredump(context)
Check for crashes reported to coredump


* **Parameters**

    **context** (*behave.Context*) – behave Context object



### nmci.crash.coredump_is_reported(dump_id)
Check if crash is already reported, to not spam repeatedly the same crash.


* **Parameters**

    **dump_id** (*str*) – unique ID of the crash, should differ across distinct crashes



* **Returns**

    True if already reported, False otherwise



* **Return type**

    bool



### nmci.crash.coredump_report(dump_id)
Save crash ID in cache, to be reported only once.


* **Parameters**

    **dump_id** (*str*) – unique ID of the crash, should differ across distinct crashes



### nmci.crash.coredump_list_on_disk(dump_type=None)
List coredumps on disk.


* **Parameters**

    **dump_type** (*obj**, **optional*) – one of COREDUMP_TYPE_SYSTEMD_COREDUMP or COREDUMP_TYPE_ABRT, defaults to None



* **Returns**

    list of filenames



* **Return type**

    list of filename



### nmci.crash.wait_faf_complete(context, dump_dir)
Waits until given FAF is uploaded and reported correctly.


* **Parameters**

    
    * **context** (*behave.Context*) – behave Context object


    * **dump_dir** (*ste*) – FAF dir to wait for



* **Returns**

    True if wait succeded, False, if report still not complete



* **Return type**

    bool



### nmci.crash.check_faf(context)
Check for new FAF reports


* **Parameters**

    **context** (*behave.Context*) – behave COntext object



### nmci.crash.after_crash_reset(context)
Do the reset of NetworkManager config and envionment, to prevent NetworkManager crashing again.


* **Parameters**

    **context** (*behave.Context*) – behave Context object


# dbus


### nmci.dbus.bus_get(bus_type=None, cancellable=None)
Returns new bus


* **Parameters**

    
    * **bus_type** (*Gio.BusType**, **optional*) – type of the bus, defaults to None


    * **cancellable** (*Gio.Cancellable**, **optional*) – cancellable object, defaults to None



* **Returns**

    new bus



* **Return type**

    Gio.Bus



### nmci.dbus.call(bus_name, object_path, interface_name, method_name, parameters=None, reply_type=None, flags=None, timeout_msec=None, bus_type=None, cancellable=None)
Call method on bus


* **Parameters**

    
    * **bus_name** (*str*) – name of the bus


    * **object_path** (*str*) – path of the object


    * **interface_name** (*str*) – name of the bus interface


    * **method_name** (*str*) – name of the method to be called


    * **parameters** (*Gio.Variant**, **optional*) – method parametrs, defaults to None


    * **reply_type** (*GLib.VariantType**, **optional*) – type of the reply, defaults to None


    * **flags** (*Gio.DBusCallFlags**, **optional*) – flags, defaults to Gio.DBusCallFlags.NONE


    * **timeout_msec** (*int**, **optional*) – timeout for given call, defaults to None


    * **bus_type** (*Gio.BusType**, **optional*) – type of bus, defaults to None


    * **cancellable** (*Gio.Cancellable**, **optional*) – cancellable object, defaults to None



* **Returns**

    returns method reply



* **Return type**

    Glib.Variant



### nmci.dbus.get_all_properties(bus_name, object_path, interface_name, flags=None, timeout_msec=None, bus_type=None, cancellable=None)
Get all properties of given object


* **Parameters**

    
    * **bus_name** (*str*) – name of the bus


    * **object_path** (*str*) – path of the object


    * **interface_name** (*str*) – name of the bus interface


    * **flags** (*Gio.DBusCallFlags**, **optional*) – flags, defaults to Gio.DBusCallFlags.NONE


    * **timeout_msec** (*int**, **optional*) – timeout for given call, defaults to None


    * **bus_type** (*Gio.BusType**, **optional*) – type of bus, defaults to None


    * **cancellable** (*Gio.Cancellable**, **optional*) – cancellable object, defaults to None



* **Returns**

    returns method reply



* **Return type**

    Glib.Variant



### nmci.dbus.get_property(bus_name, object_path, interface_name, property_name, reply_type=None, flags=None, timeout_msec=None, bus_type=None, cancellable=None)
Get property of given object


* **Parameters**

    
    * **bus_name** (*str*) – name of the bus


    * **object_path** (*str*) – path of the object


    * **interface_name** (*str*) – name of the bus interface


    * **property_name** (*str*) – name of the property to get


    * **reply_type** (*GLib.VariantType**, **optional*) – type of the reply, defaults to None


    * **flags** (*Gio.DBusCallFlags**, **optional*) – flags, defaults to Gio.DBusCallFlags.NONE


    * **timeout_msec** (*int**, **optional*) – timeout for given call, defaults to None


    * **bus_type** (*Gio.BusType**, **optional*) – type of bus, defaults to None


    * **cancellable** (*Gio.Cancellable**, **optional*) – cancellable object, defaults to None



* **Returns**

    returns method reply



* **Return type**

    Glib.Variant



### nmci.dbus.name_is_bus_name(name, check=False)
Check if given name is valid bus name


* **Parameters**

    
    * **name** (*str*) – bus name


    * **check** (*bool**, **optional*) – whether to raise if name is invalid, defaults to False



* **Raises**

    **ValueError** – if name is invalid



* **Returns**

    True if name is valid, False otherwise



* **Return type**

    bool



### nmci.dbus.name_is_interface_name(name, check=False)
Check if given name is valid interface name


* **Parameters**

    
    * **name** (*str*) – interface name


    * **check** (*bool**, **optional*) – whether to raise if name is invalid, defaults to False



* **Raises**

    **ValueError** – if name is invalid



* **Returns**

    True if name is valid, False otherwise



* **Return type**

    bool



### nmci.dbus.name_is_object_path(name, check=False)
Check if given name is valid object path


* **Parameters**

    
    * **name** (*str*) – object path


    * **check** (*bool**, **optional*) – whether to raise if path is invalid, defaults to False



* **Raises**

    **ValueError** – if path is invalid



* **Returns**

    True if path is valid, False otherwise



* **Return type**

    bool



### nmci.dbus.object_path_norm(obj_path, default_prefix=None)
The D-Bus object paths is usually something like
“/org/freedesktop/NetworkManager/Devices/43”.

For convenience, allow obj_path to be only a number, in
which case default_prefix will be prepended.


* **Parameters**

    
    * **obj_path** (*str*) – path of the object


    * **default_prefix** (*str**, **optional*) – path prefix, if given object path is relative, defaults to None



* **Returns**

    normalized object path



* **Return type**

    str


# embed


### _class_ nmci.embed.Embed(fail_only=False, combine_tag=None)
Bases: `object`

General Embed


* **Parameters**

    
    * **fail_only** (*bool**, **optional*) – whether to embed only if scenario failed, defaults to False


    * **combine_tag** (*str**, **optional*) – join multiple embeds under single caption, defaults to None



#### _class_ EmbedContext(count, embed_data)
Bases: `tuple`

Create new instance of EmbedContext(count, embed_data)


#### count()
Alias for field number 0


#### embed_data()
Alias for field number 1


#### evalDoEmbedArgs()

### _class_ nmci.embed.EmbedData(caption, data, mime_type='text/plain', fail_only=False, combine_tag=None)
Bases: `nmci.embed.Embed`

Embed General Data


* **Parameters**

    
    * **caption** (*str*) – embed caption


    * **data** (*str*) – data to be embedded


    * **mime_type** (*str**, **optional*) – mime-type of the data, defaults to “text/plain”


    * **fail_only** (*bool**, **optional*) – whether to embed only if scenario failed, defaults to False


    * **combine_tag** (*str**, **optional*) – join multiple embeds under single caption, defaults to None



### _class_ nmci.embed.EmbedLink(caption, data, fail_only=False, combine_tag=None)
Bases: `nmci.embed.Embed`

Embed links


* **Parameters**

    
    * **caption** (*str*) – embed caption


    * **data** (*list of pairs of str*) – data must be a list of 2-tuples, where the first element, is the link target (href) and the second the text.


    * **fail_only** (*bool**, **optional*) – whether to embed only if scenario failed, defaults to False


    * **combine_tag** (*str**, **optional*) – join multiple embeds under single caption, defaults to None



### nmci.embed.after_scenario_finish(status)
This is needed as last call of `after_scenario()`
The purpose of this is to separate embeds between
scenarios correctly, provide status to the formatter
and formatter also computes time spend. It is harmless
when formatter is not using pseudo steps.


* **Parameters**

    **status** (*str*) – status of the after scenario



### nmci.embed.after_step()
Sould be called after each step to refresh the combined tags.


### nmci.embed.before_scenario_finish(status)
This is needed as last call of `before_scenario()`
The purpose of this is to separate embeds between
scenarios correctly, provide status to the formatter
and formatter also computes time spend. It is harmless
when formatter is not using pseudo steps.


* **Parameters**

    **status** (*str*) – status of the before scenario



### nmci.embed.embed_data(\*a, embed_context=None, \*\*kw)

### nmci.embed.embed_dump(caption, dump_id, \*, data=None, links=None)
embed new crash dump


* **Parameters**

    
    * **caption** (*str*) – embed caption


    * **dump_id** (*str*) – unique ID of the crash


    * **data** (*str**, **optional*) – backtrace of the coredump, defaults to None


    * **links** (*list of pairs of str**, **optional*) – FAF links to embed, defaults to None



### nmci.embed.embed_file_if_exists(caption, fname, as_base64=False, fail_only=False)
Embed file to HTML report


* **Parameters**

    
    * **caption** (*str*) – embed caption


    * **fname** (*str*) – name of the file to embed


    * **as_base64** (*bool**, **optional*) – whether to convert file to base64, defaults to False


    * **fail_only** (*bool**, **optional*) – wheter to embed only if scenario fails, defaults to True



* **Returns**

    True if file exists and embedded, False otherwise



* **Return type**

    bool



### nmci.embed.embed_link(\*a, embed_context=None, \*\*kw)

### nmci.embed.embed_run(argv, shell, returncode, stdout, stderr, fail_only=True, embed_context=None, combine_tag=<object object>, elapsed_time=None)
Embed results of a process


* **Parameters**

    
    * **argv** (*list of str** or **str*) – arguments of the process


    * **shell** (*bool*) – whether executed in shell


    * **returncode** (*int*) – returncode of the process


    * **stdout** (*str** or **binary*) – STDOUT of the process


    * **stderr** (*str** or **binary*) – STDERR of the process


    * **fail_only** (*bool**, **optional*) – wheter to embed only if scenario fails, defaults to True


    * **embed_context** (*Embed.EmedContext**, **optional*) – embed context, defaults to None


    * **combine_tag** (*str**, **optional*) – caption of joined embeds, defaults to TRACE_COMBINE_TAG, computes caption from stactrace


    * **elapsed_time** (*float**, **optional*) – measured time of process run in seconds, defaults to None



### nmci.embed.embed_service_log(descr, service=None, syslog_identifier=None, journal_args=None, cursor=None, fail_only=False)
Embed log of service using journalctl


* **Parameters**

    
    * **descr** (*str*) – embed caption


    * **service** (*str**, **optional*) – name of the service to filter out, defaults to None


    * **syslog_identifier** (*str**, **optional*) – equivalent to ‘-u’ parameter of journalctl, defaults to None


    * **journal_args** (*list of str**, **optional*) – additional journalctl arguments, defaults to None


    * **cursor** (*str**, **optional*) – journalctl cursor, defaults to None


    * **fail_only** (*bool**, **optional*) – wheter to embed only if scenario fails, defaults to True



### nmci.embed.formatter_add_scenario(scenario)
Register the scenario in formatter.

This is called if skipped before scenario, because behave then does not
register the scenario to formatter.


* **Parameters**

    **scenario** (*behave.Scenario*) – scenario to be registered in formatter



### nmci.embed.get_current_scenario()
Returns the current scenario object of the HTML formatter


* **Returns**

    current scenario object in HTML formatter



* **Return type**

    formatter.Scenario



### nmci.embed.get_embed_context(combine_tag)
Returns the EmbedContext object for given combine tag, creates new if needed.


* **Parameters**

    **combine_tag** (*str*) – caption of joined embeds



* **Returns**

    EmbedContext object for given combine_tag.



* **Return type**

    EmbedContext



### nmci.embed.has_html_formatter()
Check if HTML formatter is set. This makes sense only after setup() call.


* **Returns**

    True if HTML formatter is present.



* **Return type**

    bool



### nmci.embed.process_embeds()
This is called in after scenario to process the embeds
and send data to the HTML formatter (if present).


### nmci.embed.set_title(\*a, \*\*kw)
Calls set_title() of the formatter, if supported by formatter.


### nmci.embed.setup(runner)
Save formatter from behave.Runnr object


* **Parameters**

    **runner** (*behave.Runner*) – behave Runner object


# git


### nmci.git.config_get_origin_url()
Return git origin URL, converted to HTTPS.
This is cached, `git` is called at most once per run.


* **Returns**

    git origin URL as HTTPS



* **Return type**

    str



### nmci.git.rev_parse(rev)
Return commit hash for given revision.
This is cached, `git` is called at most once per run.


* **Parameters**

    **rev** (*str*) – git revision (e.g. ‘HEAD’, ‘HEAD~7’ or branch name)



* **Raises**

    **Exception** – If git command fails



* **Returns**

    commit hash



* **Return type**

    str


# gsm


### nmci.gsm.reset_usb_devices()
Resets USB GSM devices


### nmci.gsm.reinitialize_devices()
Reinitialize GSM devices


### nmci.gsm.find_modem()
Find the 1st modem connected to a USB port or USB hub on a testing machine.

When to extract information about a modem?
- When the modem is initialized.
- When it is available in the output of  `mmcli -L`.
- When the device has type of `'gsm'` in the output of `nmcli dev`.


* **Returns**

    detected modem specified in a dictionary



* **Return type**

    str



### nmci.gsm.get_modem_info(context)
Get a list of connected modem via command `mmcli -L`.
Extract the index of the 1st modem.
Get info about the modem via command `mmcli -m $i`
Find its SIM card. This optional for this function.
Get info about the SIM card via command `mmcli --sim $i`.


* **Returns**

    modem information



* **Return type**

    str


# ip


### nmci.ip.addr_family_check(addr_family)
Check that address family is `socket.AF_INET` or `socket.AF_INET6`.


* **Parameters**

    **addr_family** (*socket.AddressFamily*) – address family



* **Raises**

    **ValueError** – when invalid address family provided



### nmci.ip.addr_family_norm(addr_family)
Normalize address family.


* **Parameters**

    **addr_family** (*socket.AddressFamily** or **string*) – address family



* **Returns**

    socket constant or None



* **Return type**

    socket.AddressFamily



### nmci.ip.addr_family_num(addr_family, allow_none=False)
Number represenation (4 or 6) of address family.


* **Parameters**

    
    * **addr_family** (*socket.AddressFamily** or **string*) – address family


    * **allow_none** (*bool**, **optional*) – whether to accept None value, defaults to False



* **Returns**

    number representation of address family



* **Return type**

    int



### nmci.ip.addr_family_plen(addr_family)
IP address length for given family


* **Parameters**

    **addr_family** (*socket.AddressFamily** or **str*) – address family



* **Returns**

    length of address



* **Return type**

    int



### nmci.ip.address_add(address, ifname=None, \*, ifindex=None, wait_for_device=None, addr_family=None, namespace=None)
Add IP address to interface.


* **Parameters**

    
    * **address** (*str*) – IP address to add


    * **ifname** (*str**, **optional*) – interafce name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interafce index, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout for device to appear, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None



### nmci.ip.address_expect(expected, ifindex=None, ifname=None, match_mode='auto', with_plen=False, ignore_order=False, ignore_extra=True, addr_family=None, wait_for_address=None, addrs=None, namespace=None)
Check if expected address is present on interface.


* **Parameters**

    
    * **expected** (*list of str** or **re.Pattern*) – list of expected addresses


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **ifname** (*str**, **optional*) – interface name, defaults to None


    * **match_mode** (*str**, **optional*) – see `nmci.util.compare_strv_list`, defaults to “auto”


    * **with_plen** (*bool**, **optional*) – whether to strip prefix or not, defaults to False


    * **ignore_order** (*bool**, **optional*) – whether to ignore address order, defaults to False


    * **ignore_extra** (*bool**, **optional*) – whether to addresses must match exactly, defaults to True


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **wait_for_address** (*float**, **optional*) – timeout until address must be present, defaults to None


    * **addrs** (*dict**, **optional*) – addreses, if set will not query `address_show()`, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None



* **Returns**

    adresses of the matched interfaces



* **Return type**

    dict



### nmci.ip.address_flush(ifname=None, \*, ifindex=None, wait_for_device=None, addr_family=None, namespace=None)
Flush addresses on given interface.


* **Parameters**

    
    * **ifname** (*str**, **optional*) – interafce name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interafec index, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout until device appears, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None



### nmci.ip.address_show(binary=None, ifindex=None, ifname=None, addr_family=None, atype=None, namespace=None)
Get addresses via `ip address show`. Possibility to filter output
by providing ifindex or ifname.


* **Parameters**

    
    * **binary** (*bool**, **optional*) – whether to return bytes, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – index of interface to show, defaults to None


    * **ifname** (*_type_**, **optional*) – interafce name to show, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **atype** (*str**, **optional*) – output only addresses of the following type, one of “inet”, “inet6”, “link/ether”, defaults to None


    * **namespace** (*str**, **optional*) – namespace to match, defaults to None



* **Returns**

    addresses for matched inetrafces



* **Return type**

    dict



### nmci.ip.ipaddr_norm(s, addr_family=None)
Normalize IP address. If address family is not provided
both IPv4 and IPv6 addresses are accepted.


* **Parameters**

    
    * **s** (*str** or **bytes*) – address


    * **addr_family** (*socket.AddressFamily** or **str** or **None**, **optional*) – address family, defaults to None



* **Returns**

    normalized address



* **Return type**

    str



### nmci.ip.ipaddr_parse(s, addr_family=None)
Parse IP address from string. If address family is not provided
both IPv4 and IPv6 addresses are accepted.


* **Parameters**

    
    * **s** (*str** or **bytes*) – address


    * **addr_family** (*socket.AddressFamily** or **str** or **None**, **optional*) – address family, defaults to None



* **Returns**

    normalized address with detected address family



* **Return type**

    tuple, str and socket.AddressFamily



### nmci.ip.ipaddr_plen_norm(s, addr_family=None)
Normalize IP address and prefix. If address family is not provided
both IPv4 and IPv6 addresses are accepted.


* **Parameters**

    
    * **s** (*str** or **bytes*) – address with prefix, e.g “1.2.3.4/31”


    * **addr_family** (*socket.AddressFamily** or **str** or **None**, **optional*) – address family, defaults to None



* **Raises**

    **ValueError** – when provided address or plen is invalid



* **Returns**

    normalized adrress with prefix



* **Return type**

    str



### nmci.ip.ipaddr_plen_parse(s, addr_family=None)
Parse IP address and prefix from string. If address family is not provided
both IPv4 and IPv6 addresses are accepted.


* **Parameters**

    
    * **s** (*str** or **bytes*) – address with prefix, e.g “1.2.3.4/31”


    * **addr_family** (*socket.AddressFamily** or **str** or **None**, **optional*) – address family, defaults to None



* **Raises**

    **ValueError** – when provided address or plen is invalid



* **Returns**

    tuple of normalized address, address family and prefix



* **Return type**

    tuple, str and socket.AddressFamily and int



### nmci.ip.ipaddr_zero(addr_family)
Zero address for given address family


* **Parameters**

    **addr_family** (*socket.AddressFamily** or **string*) – address family



* **Returns**

    “0.0.0.0” or “::”



* **Return type**

    str



### nmci.ip.link_add(ifname, link_type, \*args, ifindex=None, namespace=None, wait_for_device=None, \*\*kwargs)
Add new link. Additional arguments are appended to
`ip link add ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.


* **Parameters**

    
    * **ifname** (*str*) – interface name


    * **link_type** (*str*) – interface type


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout until device appears, defaults to None



### nmci.ip.link_delete(ifname=None, \*, ifindex=None, accept_nodev=False, namespace=None)
Delete link.


* **Parameters**

    
    * **ifname** (*str**, **optional*) – interafce name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **accept_nodev** (*bool**, **optional*) – whether to raise if device already not present, defaults to False


    * **namespace** (*str**, **optional*) – namespace, defaults to None



### nmci.ip.link_set(ifname=None, \*args, ifindex=None, up=None, wait_for_device=None, namespace=None, name=None, netns=None, master=None, \*\*kwargs)
Set link attributes. Additional arguments are appended to
`ip link set ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.


* **Parameters**

    
    * **ifname** (*str**, **optional*) – interface name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **up** (*bool**, **optional*) – if set, interface is set `up` or `down`, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout for device to appear, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None


    * **name** (*str**, **optional*) – new name for interface, defaults to None


    * **netns** (*str**, **optional*) – new namespace for interface, defaults to None


    * **master** (*str**, **optional*) – new master of interface, defaults to None



### nmci.ip.link_show(ifname=None, \*, timeout=None, \*\*kwargs)
Show single link. Interface name or index must be provided.


* **Parameters**

    
    * **timeout** (*float**, **optional*) – timeout until device must appear, defaults to None


    * **ifname** (*str**, **optional*) – interafce name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **flags** (*str**, **optional*) – interafce has to have given flags, defaults to None


    * **binary** (*bool**, **optional*) – see `link_show_all()`, defaults to None


    * **allow_missing** (*bool**, **optional*) – does not raise Exception if none interafce matched, defaults to False


    * **namespace** (*str**, **optional*) – namespace, defaults to None



* **Returns**

    attributes of matched interafce or None



* **Return type**

    dict



### nmci.ip.link_show_all(binary=None, namespace=None)
Show all links. Parameter binary can be:

`False`: expect all stings to be UTF-8, the result only contains decoded strings
`True`: expect at least some of the names to be binary, all the ifnames are bytes
`None`: expect a mix. The ifnames that can be decoded as UTF-8 are returned as strings, otherwise as bytes.


* **Parameters**

    
    * **binary** (*bool**, **optional*) – whether output should be string or binary or mixed, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None



* **Returns**

    Attributes of all availiable links



* **Return type**

    dict



### nmci.ip.link_show_maybe(ifname=None, \*, allow_missing=True, \*\*kwargs)
Show single link. Interface name or index must be provided.


* **Parameters**

    
    * **timeout** (*float**, **optional*) – timeout until device must appear, defaults to None


    * **ifname** (*str**, **optional*) – interafce name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **flags** (*str**, **optional*) – interafce has to have given flags, defaults to None


    * **binary** (*bool**, **optional*) – see `link_show_all()`, defaults to None


    * **allow_missing** (*bool**, **optional*) – does not raise Exception if none interafce matched, defaults to True


    * **namespace** (*str**, **optional*) – namespace, defaults to None



* **Returns**

    attributes of matched interafce or None



* **Return type**

    dict



### nmci.ip.mac_aton(mac_str, force_len=None)
Convert MAC address to bytes.
We also accept None and ‘’ for convenience, None yiels None, ‘’ yields [].


* **Parameters**

    
    * **mac_str** (*str*) – mac address


    * **force_len** (*int**, **optional*) – length of address in bits, defaults to None



* **Returns**

    MAC address in bytes



* **Return type**

    bytes



### nmci.ip.mac_norm(mac_str, force_len=None)
Normalize MAC address string.
We also accept None and ‘’ for convenience, None yiels None, ‘’ yields [].


* **Parameters**

    
    * **mac_str** (*str*) – mac address


    * **force_len** (*int**, **optional*) – length of address in bits, defaults to None



* **Returns**

    normalized MAC address



* **Return type**

    str



### nmci.ip.mac_ntoa(mac)
Convert bytes to MAC address string


* **Parameters**

    
    * **mac_str** (*str*) – mac address


    * **force_len** (*int**, **optional*) – length of address in bits, defaults to None



* **Returns**

    MAC address



* **Return type**

    str



### nmci.ip.netns_add(name)
Add namespace


* **Parameters**

    **name** (*str*) – name if the namespace



### nmci.ip.netns_delete(name, check=True)
Delete namespace


* **Parameters**

    
    * **name** (*str*) – name of namespace


    * **check** (*bool**, **optional*) – whether to raise if namespace already deleted, defaults to True



### nmci.ip.netns_list(with_binary=False)
List availiable namespaces.


* **Parameters**

    **with_binary** (*bool**, **optional*) – whether to return as bytes, defaults to False



* **Returns**

    list of interface names



* **Return type**

    list of str



### nmci.ip.route_add(route, ifname=None, \*args, ifindex=None, addr_family=None, namespace=None, wait_for_device=None, \*\*kwargs)
Add route.  Additional arguments are appended to
`ip route ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.


* **Parameters**

    
    * **route** (*str*) – route, address and prefix or `'default'`


    * **ifname** (*str**, **optional*) – interface name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout until device appears, defaults to None



### nmci.ip.route_del(route, ifname=None, \*args, ifindex=None, namespace=None, addr_family=None, wait_for_device=None, \*\*kwargs)
Delete route.  Additional arguments are appended to
`ip route ...` command. Additional keyword arguments are
appended with separated space: `peer='p_name'` is appended as
`'peer' 'p_name'`.


* **Parameters**

    
    * **route** (*str*) – route, address and prefix or `'default'`


    * **ifname** (*str**, **optional*) – interface name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout until device appears, defaults to None



### nmci.ip.route_flush(ifname=None, ifindex=None, namespace=None, wait_for_device=None, addr_family=None)
Flush routes.


* **Parameters**

    
    * **ifname** (*str**, **optional*) – interface name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout until device appears, defaults to None



### nmci.ip.route_show(ifname=None, ifindex=None, namespace=None, wait_for_device=None, addr_family=None)
Show routes. Returned in dictionary, where keys are routes (address with prefix)
and value is additinal arguments (allowing simple checks: `'1.2.3.4/10' in route_show()`)
TODO will not work if multiple route is having different options.


* **Parameters**

    
    * **ifname** (*str**, **optional*) – interface name, defaults to None


    * **ifindex** (*int** or **str**, **optional*) – interface index, defaults to None


    * **addr_family** (*socket.AddressFamily** or **str**, **optional*) – address family, defaults to None


    * **namespace** (*str**, **optional*) – namespace, defaults to None


    * **wait_for_device** (*float**, **optional*) – timeout until device appears, defaults to None



* **Returns**

    routes in dictionary, keyword is route address with prefix, value additional argument.


# misc


### _exception_ nmci.misc.HitRaceException()
Bases: `Exception`

Exception to be thrown, when some race condition is hit.


### _exception_ nmci.misc.InvalidTagsException()
Bases: `Exception`

Exception to be thrown, when some invalid tags are detected.


### _exception_ nmci.misc.SkipTestException()
Bases: `Exception`

Exception to be thrown when test shoud be skipped, to prevent further code execution.


### nmci.misc.distro_detect(use_cached=True)
Get distribution name and version.


* **Parameters**

    **use_cached** (*bool**, **optional*) – whether to use already processed version, defaults to True



* **Returns**

    distribution name and numerical version



* **Return type**

    tuple of string and list of int



### nmci.misc.format_dict(values, connector=' = ', separator=', ')
Universal dictionary formatter.


* **Parameters**

    
    * **values** (*dict*) – dictionary to format


    * **connector** (*str**, **optional*) – string that connects a key with its value, defaults to ” = “


    * **separator** (*str**, **optional*) – string that separates key,value pairs, defaults to “, “



* **Returns**

    string containing fomratted dictionary



* **Return type**

    str



### nmci.misc.format_duration(seconds)
Format duration in seconds to 3 decimal places and append `'s'`.


* **Parameters**

    **seconds** (*float*) – number of seconds



* **Returns**

    string containg formatted duration



* **Return type**

    str



### nmci.misc.get_dns_info(dns_plugin, ifindex=None, ifname=None)
Get DNS interface info. At least one of ifindex and ifname must be set.


* **Parameters**

    
    * **dns_plugin** (*str*) – one of `systemd-resolved` or `dnsmasq`


    * **ifindex** (*int** or **str**, **optional*) – interfave index, defaults to None


    * **ifname** (*str**, **optional*) – interface name, defaults to None



* **Returns**

    dns information



* **Return type**

    dict



### nmci.misc.get_mapper_obj()
Loads mapper as python object (dict). Yaml loader is significantly slower
than json. Since this is called multiple times per test, we convert yaml
to json cache. Json cache is not used if it does not exists or yaml file has
newer modification timestamp.


* **Returns**

    mapper



* **Return type**

    dict



### nmci.misc.get_mapper_tests(mapper, feature='\*', testmapper='\*')
Get all tests from mapper. Possible to filter specific feature or testmapper.


* **Parameters**

    
    * **mapper** (*dict*) – mapper object


    * **feature** (*str**, **optional*) – name of the feature, defaults to “\*”


    * **testmapper** (*str**, **optional*) – name of the testmapper, defaults to “\*”



* **Returns**

    list of the tests with attributes



* **Return type**

    list of dict



### nmci.misc.html_report_file_links()
Convert filenames in HTML report to links to gitlab.


### nmci.misc.html_report_tag_links()
Convert tags in HTML report to links to gitlab.


### nmci.misc.journal_get_cursor()
Get journalctl cursor, which can be used with argument `--after`


* **Returns**

    journalctl cursor



* **Return type**

    str



### nmci.misc.journal_show(service=None, \*, syslog_identifier=None, cursor=None, short=False, journal_args=None, as_bytes=False, max_size=None, warn_max_size=True, prefix=None, suffix=None)
Get journal messgages satisfying the filters.


* **Parameters**

    
    * **service** (*str**, **optional*) – shown only messages of this service, journalctl argument `-u`, defaults to None


    * **syslog_identifier** (*str**, **optional*) – shown only messages of this identifier, journalctl argument `-t`, defaults to None


    * **cursor** (*str**, **optional*) – show only messages newer than cursor, defaults to None


    * **short** (*bool**, **optional*) – shrot output format, defaults to False


    * **journal_args** (*str** or **list of str**, **optional*) – additional `journalctl` arguments, defaults to None


    * **as_bytes** (*bool**, **optional*) – wether return bytes instead of str, defaults to False


    * **max_size** (*int**, **optional*) – limit the size of output in bytes, if None then 50Mb, defaults to None


    * **warn_max_size** (*bool**, **optional*) – only show warning if max_size exceeded, do not raise, defaults to True


    * **prefix** (*str** or **bytes**, **optional*) – message placed before actual journal output, defaults to None


    * **suffix** (*str** or **bytes**, **optional*) – message placed before actual journal output, defaults to None



* **Returns**

    filtered journal messages



* **Return type**

    str



### nmci.misc.list_to_intervals(numbers)
Converts list of sorted numbers to string containing intervals.
Example: [1,2,4,5,6,7,10] -> “1,2,4..7,10”


* **Parameters**

    **numbers** – list of numbers to convert



* **Returns**

    string containing formatted list



* **Return type**

    str



### nmci.misc.nm_version_detect(use_cached=True)
Get parsed NetworkManager version. If environment variable `NM_VERSION`
is set, it is used instead of getting version by `NetworkManager -v`.


* **Parameters**

    **use_cached** (*bool**, **optional*) – whether to use already processed version, defaults to True



* **Returns**

    parsed version returned by `nm_version_parse()`



* **Return type**

    tuple of string and list of int



### nmci.misc.nm_version_parse(version)
Parses the version string from `/sbin/NetworkManager -V` and detects a version
array and a stream string.

In particular, the stream is whether this is a package from upstream or from
dist-git (fedora/fedpkg or rhel/rhpkg).

Since a package build for e.g. rhel-8.3 always has the suffix .el8, we cannot
use that reliably to detect the stream. Well, we can, but all el8 packages
that are not actually “rhel-8” stream, must have a unique version tag.
Like for example copr builds of upstream have.


* **Parameters**

    **version** (*str*) – version



* **Raises**

    **ValueError** – when unable to parse version



* **Returns**

    tuple of stream and version as list of ints



* **Return type**

    tuple of string and list of int



### nmci.misc.nmlog_parse_dnsmasq(ifname)
Return dnsmasq log as python object/dict.
Executes [`nmci/helpers/nmlog-parse-dnsmasq.sh`](nmci/helpers/nmlog-parse-dnsmasq.sh)


* **Parameters**

    **ifname** (*str*) – interafce name



* **Returns**

    parsed logs



* **Return type**

    dict



### nmci.misc.str_replace_dict(text, values, dict_name='noted')
Render templated text with values from dictionary. Can be used to
inplace `context.noted` into the string.

Examples:

`Hello <noted:name>!!!`

if provided with `{'name':'world'}`, result will be

`Hello world!!!`

dict_name controls prefix of what is being replaced, if set to `env`:

`Hello <env:here>!!!`

will be converted to `Hello there!!` if provided with `{'here':'there'}`

This allows replacement by independent dicts without need of
combining the dictionary into one and solving conflits.


* **Parameters**

    
    * **text** (*str*) – template text


    * **values** (*str*) – dictionary containing values in template


    * **dict_name** (*str**, **optional*) – prefix in template we replace, defaults to “noted”



* **Returns**

    rendered text



* **Return type**

    str



### nmci.misc.test_find_feature_file(test_name, feature='\*')
Return feature filename for given test name, gets data from `mapper.yaml`
to prevent parsing all the feature files.


* **Parameters**

    
    * **test_name** (*str*) – tag name of the test


    * **feature** (*str**, **optional*) – feature name, to narrow th search, defaults to “\*”



* **Returns**

    feature filename



* **Return type**

    str



### nmci.misc.test_get_feature_files(feature='\*')
Get list of feature files,


* **Parameters**

    **feature** (*str**, **optional*) – feature name, will interpret ‘\*’, defaults to “\*”



* **Returns**

    list of filenames



* **Return type**

    list of str



### nmci.misc.test_load_tags_from_features(feature=None, test_name=None, feature_file=None)
Load test tags from feature.


* **Parameters**

    
    * **feature** (*str**, **optional*) – name of the featue, defaults to None


    * **test_name** (*str**, **optional*) – tag name of the test, defaults to None


    * **feature_file** (*str**, **optional*) – filename of the feature file, defaults to None



* **Returns**

    list of tags of the tests



* **Return type**

    list of list of str



### nmci.misc.test_load_tags_from_file(filename, test_name=None)
Load tags from feature file.

We memoize the result of the parsing. Feel free to
`delattr(self, "_test_load_tags_from_file_cache")` to
prune the cache.


* **Parameters**

    
    * **filename** (*str*) – feature file name


    * **test_name** (*str**, **optional*) – tag name of the test, defaults to None



* **Returns**

    list of test tags



* **Return type**

    list of list of str



### nmci.misc.test_name_normalize(test_name)
Normalize testname, raise if invalid characters are contained.


* **Parameters**

    **test_name** (*str*) – name of the test



* **Raises**

    **ValueError** – when name is invalid



* **Returns**

    normalized name of the test



* **Return type**

    str



### nmci.misc.test_tags_match_version(test_tags, nm_version_info, distro_version_info)
Check if tags match the versions of NetworkManager and distro


* **Parameters**

    
    * **test_tags** (*list of string*) – all tags for given test


    * **nm_version_info** (*tuple of string and list of int*) – parsed NetworkManager version `(stream, version)`


    * **distro_version_info** (*tuple of string and list of int*) – parsed distro version `(flavor, version)`



* **Returns**

    test_tags if they match versions, None otherwise



* **Return type**

    list of string



### nmci.misc.test_tags_select(test_tags_list, nm_version_info, distro_version_info)
Picks the test that satisfies the versions.


* **Parameters**

    
    * **test_tags_list** (*list of list of str*) – list of tests (test is list of tags)


    * **nm_version_info** (*tuple of string and list of int*) – parsed NetworkManager version `(stream, version)`


    * **distro_version_info** (*tuple of string and list of int*) – parsed distro version `(flavor, version)`



* **Raises**

    
    * **self.InvalidTagsException** – when multiple tests matches


    * **self.SkipTestException** – when none test is matched



* **Returns**

    tags of the matched test



* **Return type**

    list of string



### nmci.misc.test_version_check(test_name, feature='\*')
This is called by version control [`nmci/helpers/version_control.py`](nmci/helpers/version_control.py)

this checks for tests with given tag and returns all tags of the first test satisfying all conditions

this parses tags: `ver{-,+,-=,+=}, rhelver{-,+,-=,+=}, fedoraver{-,+,-=,+=}, [not_with_]rhel_pkg, [not_with_]fedora_pkg`.

{rhel,fedora}ver tags restricts only their distros, so rhelver+=8 runs on all Fedoras, if fedoraver not restricted
to not to run on rhel / fedora use tags rhelver-=0 / fedoraver-=0 (or something similar)

`{rhel,fedora}_pkg means` to run only on stock RHEL/Fedora package
`not_with_{rhel,fedora}_pkg` means to run only on daily build (not patched stock package)
similarly, `\*_pkg` restricts only their distros, `rhel_pkg` will run on all Fedoras (build and stock pkg)

since the first satisfying test is returned, the last test does not have to contain distro restrictions
and it will run only in remaining conditions - so order of the tests matters in this case


* **Parameters**

    
    * **test_name** (*str*) – tag name of the test


    * **feature** (*str**, **optional*) – name of the feature, defaults to “\*”



* **Returns**

    feature filename and testname and list of all test tags



* **Return type**

    tuple of str and str and list of str



### nmci.misc.test_version_tag_eval(ver_tags, version)
This is how we interpret the “ver+”/”ver-” version tags.
This scheme makes sense for versioning schemes where we have a main
branch (where major releases get tagged) and stable branches (with
minor releases). This is the versioning scheme of NetworkManager
(“ver” tag) but it also works for “rhelver”/”fedoraver”.

Currently it only supports a main branch (with major releases)
and stable branches (with minor releases) that branch off the
main branch. It does not support a second level of bugfix branches
that branch off stable branches, but that could be implemented too.

Notes:

1) the version tags ‘-‘/’+’ are just convenience forms of ‘-=’/’+=’. They
need no special consideration (“+1.28.5” is exactly the same as “+=1.28.6”).

2) if both ‘-=’ and ‘+=’ are present, they might either define single closed range
e.g. “ver+=1.26, ver-=1.30”, or a “hole” (buggy interval), e.g. “ver-=1.26, ver+=1.30”.

3) version tags can either specify the full version (“ver+=1.26.4”) or only the major
component (“ver+=1.27”).
Of all the version tags of the same ‘+’/’-’ group, the shortest and highest one also
determines the next major version.
For example, with “ver+=1.26.4, ver+=1.28.2” both tags have 3 components (they
both are the “shortest”). Of these, “ver+=1.28.2” is the highest one. From that we
automatically also get “ver+=1.29[.0]” and ver+=2[.0.0]”.
This means, if you specify the latest stable version (1.28.2) that introduced a feature,
then automatically all newer major versions are covered.
Basically, the shortest and highest tag determines the major branch. If you have
more tags of the same ‘+’/’-’ type, then those are only for the stable branch.
With example “ver+=1.26.4, ver+=1.28.2”, the first tag only covers 1.26.4+ stable
versions, nothing else.

4) for each ‘+’ version tag that comes right after ‘+’ version tag (when sorted ascending),
there is added ‘-’ tag, keeping only first 2 parts of version:
- “ver+=1.28.6 ver+=1.30.1” is equivalent to “ver+=1.28.6 ver-1.30 ver+=1.30.1”
meaning, that 1.29.x is satisfied, but 1.30.0 is skipped

5) for each ‘-’ version tag that comes right before ‘-’ version tag (when sorted ascending),
there is added ‘+’ tag keeping only first 2 parts of version and adding “9999.9999” :
- “ver-=1.28.6 ver-=1.30.1” is equivalent to “ver-=1.28.6 ver+1.28.9999.9999 ver-=1.30.1”


* **Parameters**

    
    * **ver_tags** (*list of tuple of string and list of int*) – parsed version tags of the test in form of `(operation, version)`


    * **version** (*list of int*) – parsed version to compare (of NetworkManager or distro)



* **Returns**

    whether the version satisfy conditions prescribed by tags



* **Return type**

    bool



### nmci.misc.test_version_tag_filter_for_stream(tags_ver, nm_stream)
This function now returns a list of (op,version) tuple, but only selecting
those that have a matching stream… that means, if the nm_stream is
“rhel-8-10”, then:

> 
> * if exist, it will return all tags_ver with stream `["rhel", "8", "10"]`


> * if exist, it will return all tags_ver with stream `["rhel", "8"]`


> * if exist, it will return all tags_ver with stream `["rhel"]`


> * if exist, it will return all tags_ver with stream `[]`

With this scheme, you can have a default version tag that always matches (`@ver+=1.39`),
but you can override it for rhel (`@ver/rhel+=x`) or even for rhel-8 only (`@ver/rhel/8+=x`)


* **Parameters**

    
    * **tags_ver** (*tuple of string and string and list of ints*) – list of version tags parsed by `test_version_tag_parse_ver()` (it contains a 3-tuple of (stream, op, version)


    * **nm_stream** (*str*) – the stream detected by `nm_version_parse()`, for example `rhel-8-10` or `fedora-33`



* **Returns**

    filtered versions with matching stream



* **Return type**

    list of tuple of string and list of int



### nmci.misc.test_version_tag_parse(version_tag, tag_candidate)
Parse version tag into operator and version, given that prefix is preparsed.


* **Parameters**

    
    * **version_tag** (*str*) – version tag


    * **tag_candidate** (*str*) – prefix of the version tag (e.g. `'ver'` or `'ver/rhel/8'`)



* **Returns**

    tuple of operator and version as list of int



* **Return type**

    tuple of str and list of int



### nmci.misc.test_version_tag_parse_ver(version_tag)
This parses tags in the form @ver$STREAM$OP$VERSION where


* $STREAM is for example “”, “/upstream”, “/fedora”, “/fedora/33”, “/rhel”, “/rhel/8”. It matches
the stream returned by nm_version_parse().


* $OP is the comparison operator (“-”, “-=”, “+”, “+=”)


* $VERSION is the version number to compare. Corresponds the version returned by `nm_version_parse()`.


* **Parameters**

    **version_tag** (*str*) – version tag



* **Raises**

    **ValueError** – if version tag is invalid



* **Returns**

    tuple of stream and operator and version



* **Return type**

    tuple of string and string and list of ints



### nmci.misc.ver_param_to_str(nm_stream, nm_version, distro_flavor, distro_version)
String represenation of parsed NetworkManager and distro version


* **Parameters**

    
    * **nm_stream** (*str*) – NetworkManager stream


    * **nm_version** (*list of int*) – NetworkManager version


    * **distro_flavor** (*str*) – distribution flavor name


    * **distro_version** (*list of int*) – distribution version



* **Returns**

    formatted arguments, versions are dot separated integers `nm_stream:nm_version (distro_flavor:distro_version)`



* **Return type**

    str
